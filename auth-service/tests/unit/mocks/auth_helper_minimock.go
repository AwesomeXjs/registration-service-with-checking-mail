// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/AwesomeXjs/registration-service-with-checking-mail/server/auth-service/internal/utils/auth_helper.AuthHelper -o auth_helper_minimock.go -n AuthHelperMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/AwesomeXjs/registration-service-with-checking-mail/server/auth-service/internal/model"
	"github.com/gojuno/minimock/v3"
)

// AuthHelperMock implements mm_auth_helper.AuthHelper
type AuthHelperMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGenerateAccessToken          func(info *model.AccessTokenInfo) (s1 string, err error)
	funcGenerateAccessTokenOrigin    string
	inspectFuncGenerateAccessToken   func(info *model.AccessTokenInfo)
	afterGenerateAccessTokenCounter  uint64
	beforeGenerateAccessTokenCounter uint64
	GenerateAccessTokenMock          mAuthHelperMockGenerateAccessToken

	funcGenerateRefreshToken          func(userID string) (s1 string, err error)
	funcGenerateRefreshTokenOrigin    string
	inspectFuncGenerateRefreshToken   func(userID string)
	afterGenerateRefreshTokenCounter  uint64
	beforeGenerateRefreshTokenCounter uint64
	GenerateRefreshTokenMock          mAuthHelperMockGenerateRefreshToken

	funcHashPassword          func(password string) (s1 string, err error)
	funcHashPasswordOrigin    string
	inspectFuncHashPassword   func(password string)
	afterHashPasswordCounter  uint64
	beforeHashPasswordCounter uint64
	HashPasswordMock          mAuthHelperMockHashPassword

	funcValidatePassword          func(hashedPassword string, candidatePassword string) (b1 bool)
	funcValidatePasswordOrigin    string
	inspectFuncValidatePassword   func(hashedPassword string, candidatePassword string)
	afterValidatePasswordCounter  uint64
	beforeValidatePasswordCounter uint64
	ValidatePasswordMock          mAuthHelperMockValidatePassword

	funcVerifyToken          func(token string) (up1 *model.UserClaims, err error)
	funcVerifyTokenOrigin    string
	inspectFuncVerifyToken   func(token string)
	afterVerifyTokenCounter  uint64
	beforeVerifyTokenCounter uint64
	VerifyTokenMock          mAuthHelperMockVerifyToken
}

// NewAuthHelperMock returns a mock for mm_auth_helper.AuthHelper
func NewAuthHelperMock(t minimock.Tester) *AuthHelperMock {
	m := &AuthHelperMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateAccessTokenMock = mAuthHelperMockGenerateAccessToken{mock: m}
	m.GenerateAccessTokenMock.callArgs = []*AuthHelperMockGenerateAccessTokenParams{}

	m.GenerateRefreshTokenMock = mAuthHelperMockGenerateRefreshToken{mock: m}
	m.GenerateRefreshTokenMock.callArgs = []*AuthHelperMockGenerateRefreshTokenParams{}

	m.HashPasswordMock = mAuthHelperMockHashPassword{mock: m}
	m.HashPasswordMock.callArgs = []*AuthHelperMockHashPasswordParams{}

	m.ValidatePasswordMock = mAuthHelperMockValidatePassword{mock: m}
	m.ValidatePasswordMock.callArgs = []*AuthHelperMockValidatePasswordParams{}

	m.VerifyTokenMock = mAuthHelperMockVerifyToken{mock: m}
	m.VerifyTokenMock.callArgs = []*AuthHelperMockVerifyTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthHelperMockGenerateAccessToken struct {
	optional           bool
	mock               *AuthHelperMock
	defaultExpectation *AuthHelperMockGenerateAccessTokenExpectation
	expectations       []*AuthHelperMockGenerateAccessTokenExpectation

	callArgs []*AuthHelperMockGenerateAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHelperMockGenerateAccessTokenExpectation specifies expectation struct of the AuthHelper.GenerateAccessToken
type AuthHelperMockGenerateAccessTokenExpectation struct {
	mock               *AuthHelperMock
	params             *AuthHelperMockGenerateAccessTokenParams
	paramPtrs          *AuthHelperMockGenerateAccessTokenParamPtrs
	expectationOrigins AuthHelperMockGenerateAccessTokenExpectationOrigins
	results            *AuthHelperMockGenerateAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthHelperMockGenerateAccessTokenParams contains parameters of the AuthHelper.GenerateAccessToken
type AuthHelperMockGenerateAccessTokenParams struct {
	info *model.AccessTokenInfo
}

// AuthHelperMockGenerateAccessTokenParamPtrs contains pointers to parameters of the AuthHelper.GenerateAccessToken
type AuthHelperMockGenerateAccessTokenParamPtrs struct {
	info **model.AccessTokenInfo
}

// AuthHelperMockGenerateAccessTokenResults contains results of the AuthHelper.GenerateAccessToken
type AuthHelperMockGenerateAccessTokenResults struct {
	s1  string
	err error
}

// AuthHelperMockGenerateAccessTokenOrigins contains origins of expectations of the AuthHelper.GenerateAccessToken
type AuthHelperMockGenerateAccessTokenExpectationOrigins struct {
	origin     string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) Optional() *mAuthHelperMockGenerateAccessToken {
	mmGenerateAccessToken.optional = true
	return mmGenerateAccessToken
}

// Expect sets up expected params for AuthHelper.GenerateAccessToken
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) Expect(info *model.AccessTokenInfo) *mAuthHelperMockGenerateAccessToken {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("AuthHelperMock.GenerateAccessToken mock is already set by Set")
	}

	if mmGenerateAccessToken.defaultExpectation == nil {
		mmGenerateAccessToken.defaultExpectation = &AuthHelperMockGenerateAccessTokenExpectation{}
	}

	if mmGenerateAccessToken.defaultExpectation.paramPtrs != nil {
		mmGenerateAccessToken.mock.t.Fatalf("AuthHelperMock.GenerateAccessToken mock is already set by ExpectParams functions")
	}

	mmGenerateAccessToken.defaultExpectation.params = &AuthHelperMockGenerateAccessTokenParams{info}
	mmGenerateAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateAccessToken.expectations {
		if minimock.Equal(e.params, mmGenerateAccessToken.defaultExpectation.params) {
			mmGenerateAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateAccessToken.defaultExpectation.params)
		}
	}

	return mmGenerateAccessToken
}

// ExpectInfoParam1 sets up expected param info for AuthHelper.GenerateAccessToken
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) ExpectInfoParam1(info *model.AccessTokenInfo) *mAuthHelperMockGenerateAccessToken {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("AuthHelperMock.GenerateAccessToken mock is already set by Set")
	}

	if mmGenerateAccessToken.defaultExpectation == nil {
		mmGenerateAccessToken.defaultExpectation = &AuthHelperMockGenerateAccessTokenExpectation{}
	}

	if mmGenerateAccessToken.defaultExpectation.params != nil {
		mmGenerateAccessToken.mock.t.Fatalf("AuthHelperMock.GenerateAccessToken mock is already set by Expect")
	}

	if mmGenerateAccessToken.defaultExpectation.paramPtrs == nil {
		mmGenerateAccessToken.defaultExpectation.paramPtrs = &AuthHelperMockGenerateAccessTokenParamPtrs{}
	}
	mmGenerateAccessToken.defaultExpectation.paramPtrs.info = &info
	mmGenerateAccessToken.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmGenerateAccessToken
}

// Inspect accepts an inspector function that has same arguments as the AuthHelper.GenerateAccessToken
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) Inspect(f func(info *model.AccessTokenInfo)) *mAuthHelperMockGenerateAccessToken {
	if mmGenerateAccessToken.mock.inspectFuncGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("Inspect function is already set for AuthHelperMock.GenerateAccessToken")
	}

	mmGenerateAccessToken.mock.inspectFuncGenerateAccessToken = f

	return mmGenerateAccessToken
}

// Return sets up results that will be returned by AuthHelper.GenerateAccessToken
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) Return(s1 string, err error) *AuthHelperMock {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("AuthHelperMock.GenerateAccessToken mock is already set by Set")
	}

	if mmGenerateAccessToken.defaultExpectation == nil {
		mmGenerateAccessToken.defaultExpectation = &AuthHelperMockGenerateAccessTokenExpectation{mock: mmGenerateAccessToken.mock}
	}
	mmGenerateAccessToken.defaultExpectation.results = &AuthHelperMockGenerateAccessTokenResults{s1, err}
	mmGenerateAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateAccessToken.mock
}

// Set uses given function f to mock the AuthHelper.GenerateAccessToken method
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) Set(f func(info *model.AccessTokenInfo) (s1 string, err error)) *AuthHelperMock {
	if mmGenerateAccessToken.defaultExpectation != nil {
		mmGenerateAccessToken.mock.t.Fatalf("Default expectation is already set for the AuthHelper.GenerateAccessToken method")
	}

	if len(mmGenerateAccessToken.expectations) > 0 {
		mmGenerateAccessToken.mock.t.Fatalf("Some expectations are already set for the AuthHelper.GenerateAccessToken method")
	}

	mmGenerateAccessToken.mock.funcGenerateAccessToken = f
	mmGenerateAccessToken.mock.funcGenerateAccessTokenOrigin = minimock.CallerInfo(1)
	return mmGenerateAccessToken.mock
}

// When sets expectation for the AuthHelper.GenerateAccessToken which will trigger the result defined by the following
// Then helper
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) When(info *model.AccessTokenInfo) *AuthHelperMockGenerateAccessTokenExpectation {
	if mmGenerateAccessToken.mock.funcGenerateAccessToken != nil {
		mmGenerateAccessToken.mock.t.Fatalf("AuthHelperMock.GenerateAccessToken mock is already set by Set")
	}

	expectation := &AuthHelperMockGenerateAccessTokenExpectation{
		mock:               mmGenerateAccessToken.mock,
		params:             &AuthHelperMockGenerateAccessTokenParams{info},
		expectationOrigins: AuthHelperMockGenerateAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateAccessToken.expectations = append(mmGenerateAccessToken.expectations, expectation)
	return expectation
}

// Then sets up AuthHelper.GenerateAccessToken return parameters for the expectation previously defined by the When method
func (e *AuthHelperMockGenerateAccessTokenExpectation) Then(s1 string, err error) *AuthHelperMock {
	e.results = &AuthHelperMockGenerateAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times AuthHelper.GenerateAccessToken should be invoked
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) Times(n uint64) *mAuthHelperMockGenerateAccessToken {
	if n == 0 {
		mmGenerateAccessToken.mock.t.Fatalf("Times of AuthHelperMock.GenerateAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateAccessToken.expectedInvocations, n)
	mmGenerateAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateAccessToken
}

func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) invocationsDone() bool {
	if len(mmGenerateAccessToken.expectations) == 0 && mmGenerateAccessToken.defaultExpectation == nil && mmGenerateAccessToken.mock.funcGenerateAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateAccessToken.mock.afterGenerateAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateAccessToken implements mm_auth_helper.AuthHelper
func (mmGenerateAccessToken *AuthHelperMock) GenerateAccessToken(info *model.AccessTokenInfo) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateAccessToken.beforeGenerateAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateAccessToken.afterGenerateAccessTokenCounter, 1)

	mmGenerateAccessToken.t.Helper()

	if mmGenerateAccessToken.inspectFuncGenerateAccessToken != nil {
		mmGenerateAccessToken.inspectFuncGenerateAccessToken(info)
	}

	mm_params := AuthHelperMockGenerateAccessTokenParams{info}

	// Record call args
	mmGenerateAccessToken.GenerateAccessTokenMock.mutex.Lock()
	mmGenerateAccessToken.GenerateAccessTokenMock.callArgs = append(mmGenerateAccessToken.GenerateAccessTokenMock.callArgs, &mm_params)
	mmGenerateAccessToken.GenerateAccessTokenMock.mutex.Unlock()

	for _, e := range mmGenerateAccessToken.GenerateAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthHelperMockGenerateAccessTokenParams{info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmGenerateAccessToken.t.Errorf("AuthHelperMock.GenerateAccessToken got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateAccessToken.t.Errorf("AuthHelperMock.GenerateAccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateAccessToken.GenerateAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateAccessToken.t.Fatal("No results are set for the AuthHelperMock.GenerateAccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateAccessToken.funcGenerateAccessToken != nil {
		return mmGenerateAccessToken.funcGenerateAccessToken(info)
	}
	mmGenerateAccessToken.t.Fatalf("Unexpected call to AuthHelperMock.GenerateAccessToken. %v", info)
	return
}

// GenerateAccessTokenAfterCounter returns a count of finished AuthHelperMock.GenerateAccessToken invocations
func (mmGenerateAccessToken *AuthHelperMock) GenerateAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateAccessToken.afterGenerateAccessTokenCounter)
}

// GenerateAccessTokenBeforeCounter returns a count of AuthHelperMock.GenerateAccessToken invocations
func (mmGenerateAccessToken *AuthHelperMock) GenerateAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateAccessToken.beforeGenerateAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthHelperMock.GenerateAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateAccessToken *mAuthHelperMockGenerateAccessToken) Calls() []*AuthHelperMockGenerateAccessTokenParams {
	mmGenerateAccessToken.mutex.RLock()

	argCopy := make([]*AuthHelperMockGenerateAccessTokenParams, len(mmGenerateAccessToken.callArgs))
	copy(argCopy, mmGenerateAccessToken.callArgs)

	mmGenerateAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateAccessTokenDone returns true if the count of the GenerateAccessToken invocations corresponds
// the number of defined expectations
func (m *AuthHelperMock) MinimockGenerateAccessTokenDone() bool {
	if m.GenerateAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateAccessTokenMock.invocationsDone()
}

// MinimockGenerateAccessTokenInspect logs each unmet expectation
func (m *AuthHelperMock) MinimockGenerateAccessTokenInspect() {
	for _, e := range m.GenerateAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHelperMock.GenerateAccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateAccessTokenCounter := mm_atomic.LoadUint64(&m.afterGenerateAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateAccessTokenMock.defaultExpectation != nil && afterGenerateAccessTokenCounter < 1 {
		if m.GenerateAccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHelperMock.GenerateAccessToken at\n%s", m.GenerateAccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHelperMock.GenerateAccessToken at\n%s with params: %#v", m.GenerateAccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.GenerateAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateAccessToken != nil && afterGenerateAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthHelperMock.GenerateAccessToken at\n%s", m.funcGenerateAccessTokenOrigin)
	}

	if !m.GenerateAccessTokenMock.invocationsDone() && afterGenerateAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHelperMock.GenerateAccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateAccessTokenMock.expectedInvocations), m.GenerateAccessTokenMock.expectedInvocationsOrigin, afterGenerateAccessTokenCounter)
	}
}

type mAuthHelperMockGenerateRefreshToken struct {
	optional           bool
	mock               *AuthHelperMock
	defaultExpectation *AuthHelperMockGenerateRefreshTokenExpectation
	expectations       []*AuthHelperMockGenerateRefreshTokenExpectation

	callArgs []*AuthHelperMockGenerateRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHelperMockGenerateRefreshTokenExpectation specifies expectation struct of the AuthHelper.GenerateRefreshToken
type AuthHelperMockGenerateRefreshTokenExpectation struct {
	mock               *AuthHelperMock
	params             *AuthHelperMockGenerateRefreshTokenParams
	paramPtrs          *AuthHelperMockGenerateRefreshTokenParamPtrs
	expectationOrigins AuthHelperMockGenerateRefreshTokenExpectationOrigins
	results            *AuthHelperMockGenerateRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthHelperMockGenerateRefreshTokenParams contains parameters of the AuthHelper.GenerateRefreshToken
type AuthHelperMockGenerateRefreshTokenParams struct {
	userID string
}

// AuthHelperMockGenerateRefreshTokenParamPtrs contains pointers to parameters of the AuthHelper.GenerateRefreshToken
type AuthHelperMockGenerateRefreshTokenParamPtrs struct {
	userID *string
}

// AuthHelperMockGenerateRefreshTokenResults contains results of the AuthHelper.GenerateRefreshToken
type AuthHelperMockGenerateRefreshTokenResults struct {
	s1  string
	err error
}

// AuthHelperMockGenerateRefreshTokenOrigins contains origins of expectations of the AuthHelper.GenerateRefreshToken
type AuthHelperMockGenerateRefreshTokenExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) Optional() *mAuthHelperMockGenerateRefreshToken {
	mmGenerateRefreshToken.optional = true
	return mmGenerateRefreshToken
}

// Expect sets up expected params for AuthHelper.GenerateRefreshToken
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) Expect(userID string) *mAuthHelperMockGenerateRefreshToken {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("AuthHelperMock.GenerateRefreshToken mock is already set by Set")
	}

	if mmGenerateRefreshToken.defaultExpectation == nil {
		mmGenerateRefreshToken.defaultExpectation = &AuthHelperMockGenerateRefreshTokenExpectation{}
	}

	if mmGenerateRefreshToken.defaultExpectation.paramPtrs != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("AuthHelperMock.GenerateRefreshToken mock is already set by ExpectParams functions")
	}

	mmGenerateRefreshToken.defaultExpectation.params = &AuthHelperMockGenerateRefreshTokenParams{userID}
	mmGenerateRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateRefreshToken.expectations {
		if minimock.Equal(e.params, mmGenerateRefreshToken.defaultExpectation.params) {
			mmGenerateRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateRefreshToken.defaultExpectation.params)
		}
	}

	return mmGenerateRefreshToken
}

// ExpectUserIDParam1 sets up expected param userID for AuthHelper.GenerateRefreshToken
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) ExpectUserIDParam1(userID string) *mAuthHelperMockGenerateRefreshToken {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("AuthHelperMock.GenerateRefreshToken mock is already set by Set")
	}

	if mmGenerateRefreshToken.defaultExpectation == nil {
		mmGenerateRefreshToken.defaultExpectation = &AuthHelperMockGenerateRefreshTokenExpectation{}
	}

	if mmGenerateRefreshToken.defaultExpectation.params != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("AuthHelperMock.GenerateRefreshToken mock is already set by Expect")
	}

	if mmGenerateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGenerateRefreshToken.defaultExpectation.paramPtrs = &AuthHelperMockGenerateRefreshTokenParamPtrs{}
	}
	mmGenerateRefreshToken.defaultExpectation.paramPtrs.userID = &userID
	mmGenerateRefreshToken.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGenerateRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the AuthHelper.GenerateRefreshToken
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) Inspect(f func(userID string)) *mAuthHelperMockGenerateRefreshToken {
	if mmGenerateRefreshToken.mock.inspectFuncGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("Inspect function is already set for AuthHelperMock.GenerateRefreshToken")
	}

	mmGenerateRefreshToken.mock.inspectFuncGenerateRefreshToken = f

	return mmGenerateRefreshToken
}

// Return sets up results that will be returned by AuthHelper.GenerateRefreshToken
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) Return(s1 string, err error) *AuthHelperMock {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("AuthHelperMock.GenerateRefreshToken mock is already set by Set")
	}

	if mmGenerateRefreshToken.defaultExpectation == nil {
		mmGenerateRefreshToken.defaultExpectation = &AuthHelperMockGenerateRefreshTokenExpectation{mock: mmGenerateRefreshToken.mock}
	}
	mmGenerateRefreshToken.defaultExpectation.results = &AuthHelperMockGenerateRefreshTokenResults{s1, err}
	mmGenerateRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateRefreshToken.mock
}

// Set uses given function f to mock the AuthHelper.GenerateRefreshToken method
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) Set(f func(userID string) (s1 string, err error)) *AuthHelperMock {
	if mmGenerateRefreshToken.defaultExpectation != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("Default expectation is already set for the AuthHelper.GenerateRefreshToken method")
	}

	if len(mmGenerateRefreshToken.expectations) > 0 {
		mmGenerateRefreshToken.mock.t.Fatalf("Some expectations are already set for the AuthHelper.GenerateRefreshToken method")
	}

	mmGenerateRefreshToken.mock.funcGenerateRefreshToken = f
	mmGenerateRefreshToken.mock.funcGenerateRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmGenerateRefreshToken.mock
}

// When sets expectation for the AuthHelper.GenerateRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) When(userID string) *AuthHelperMockGenerateRefreshTokenExpectation {
	if mmGenerateRefreshToken.mock.funcGenerateRefreshToken != nil {
		mmGenerateRefreshToken.mock.t.Fatalf("AuthHelperMock.GenerateRefreshToken mock is already set by Set")
	}

	expectation := &AuthHelperMockGenerateRefreshTokenExpectation{
		mock:               mmGenerateRefreshToken.mock,
		params:             &AuthHelperMockGenerateRefreshTokenParams{userID},
		expectationOrigins: AuthHelperMockGenerateRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateRefreshToken.expectations = append(mmGenerateRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up AuthHelper.GenerateRefreshToken return parameters for the expectation previously defined by the When method
func (e *AuthHelperMockGenerateRefreshTokenExpectation) Then(s1 string, err error) *AuthHelperMock {
	e.results = &AuthHelperMockGenerateRefreshTokenResults{s1, err}
	return e.mock
}

// Times sets number of times AuthHelper.GenerateRefreshToken should be invoked
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) Times(n uint64) *mAuthHelperMockGenerateRefreshToken {
	if n == 0 {
		mmGenerateRefreshToken.mock.t.Fatalf("Times of AuthHelperMock.GenerateRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateRefreshToken.expectedInvocations, n)
	mmGenerateRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateRefreshToken
}

func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) invocationsDone() bool {
	if len(mmGenerateRefreshToken.expectations) == 0 && mmGenerateRefreshToken.defaultExpectation == nil && mmGenerateRefreshToken.mock.funcGenerateRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateRefreshToken.mock.afterGenerateRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateRefreshToken implements mm_auth_helper.AuthHelper
func (mmGenerateRefreshToken *AuthHelperMock) GenerateRefreshToken(userID string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateRefreshToken.beforeGenerateRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateRefreshToken.afterGenerateRefreshTokenCounter, 1)

	mmGenerateRefreshToken.t.Helper()

	if mmGenerateRefreshToken.inspectFuncGenerateRefreshToken != nil {
		mmGenerateRefreshToken.inspectFuncGenerateRefreshToken(userID)
	}

	mm_params := AuthHelperMockGenerateRefreshTokenParams{userID}

	// Record call args
	mmGenerateRefreshToken.GenerateRefreshTokenMock.mutex.Lock()
	mmGenerateRefreshToken.GenerateRefreshTokenMock.callArgs = append(mmGenerateRefreshToken.GenerateRefreshTokenMock.callArgs, &mm_params)
	mmGenerateRefreshToken.GenerateRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGenerateRefreshToken.GenerateRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthHelperMockGenerateRefreshTokenParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGenerateRefreshToken.t.Errorf("AuthHelperMock.GenerateRefreshToken got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateRefreshToken.t.Errorf("AuthHelperMock.GenerateRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateRefreshToken.GenerateRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateRefreshToken.t.Fatal("No results are set for the AuthHelperMock.GenerateRefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateRefreshToken.funcGenerateRefreshToken != nil {
		return mmGenerateRefreshToken.funcGenerateRefreshToken(userID)
	}
	mmGenerateRefreshToken.t.Fatalf("Unexpected call to AuthHelperMock.GenerateRefreshToken. %v", userID)
	return
}

// GenerateRefreshTokenAfterCounter returns a count of finished AuthHelperMock.GenerateRefreshToken invocations
func (mmGenerateRefreshToken *AuthHelperMock) GenerateRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateRefreshToken.afterGenerateRefreshTokenCounter)
}

// GenerateRefreshTokenBeforeCounter returns a count of AuthHelperMock.GenerateRefreshToken invocations
func (mmGenerateRefreshToken *AuthHelperMock) GenerateRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateRefreshToken.beforeGenerateRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthHelperMock.GenerateRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateRefreshToken *mAuthHelperMockGenerateRefreshToken) Calls() []*AuthHelperMockGenerateRefreshTokenParams {
	mmGenerateRefreshToken.mutex.RLock()

	argCopy := make([]*AuthHelperMockGenerateRefreshTokenParams, len(mmGenerateRefreshToken.callArgs))
	copy(argCopy, mmGenerateRefreshToken.callArgs)

	mmGenerateRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateRefreshTokenDone returns true if the count of the GenerateRefreshToken invocations corresponds
// the number of defined expectations
func (m *AuthHelperMock) MinimockGenerateRefreshTokenDone() bool {
	if m.GenerateRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateRefreshTokenMock.invocationsDone()
}

// MinimockGenerateRefreshTokenInspect logs each unmet expectation
func (m *AuthHelperMock) MinimockGenerateRefreshTokenInspect() {
	for _, e := range m.GenerateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHelperMock.GenerateRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterGenerateRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateRefreshTokenMock.defaultExpectation != nil && afterGenerateRefreshTokenCounter < 1 {
		if m.GenerateRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHelperMock.GenerateRefreshToken at\n%s", m.GenerateRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHelperMock.GenerateRefreshToken at\n%s with params: %#v", m.GenerateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.GenerateRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateRefreshToken != nil && afterGenerateRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthHelperMock.GenerateRefreshToken at\n%s", m.funcGenerateRefreshTokenOrigin)
	}

	if !m.GenerateRefreshTokenMock.invocationsDone() && afterGenerateRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHelperMock.GenerateRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateRefreshTokenMock.expectedInvocations), m.GenerateRefreshTokenMock.expectedInvocationsOrigin, afterGenerateRefreshTokenCounter)
	}
}

type mAuthHelperMockHashPassword struct {
	optional           bool
	mock               *AuthHelperMock
	defaultExpectation *AuthHelperMockHashPasswordExpectation
	expectations       []*AuthHelperMockHashPasswordExpectation

	callArgs []*AuthHelperMockHashPasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHelperMockHashPasswordExpectation specifies expectation struct of the AuthHelper.HashPassword
type AuthHelperMockHashPasswordExpectation struct {
	mock               *AuthHelperMock
	params             *AuthHelperMockHashPasswordParams
	paramPtrs          *AuthHelperMockHashPasswordParamPtrs
	expectationOrigins AuthHelperMockHashPasswordExpectationOrigins
	results            *AuthHelperMockHashPasswordResults
	returnOrigin       string
	Counter            uint64
}

// AuthHelperMockHashPasswordParams contains parameters of the AuthHelper.HashPassword
type AuthHelperMockHashPasswordParams struct {
	password string
}

// AuthHelperMockHashPasswordParamPtrs contains pointers to parameters of the AuthHelper.HashPassword
type AuthHelperMockHashPasswordParamPtrs struct {
	password *string
}

// AuthHelperMockHashPasswordResults contains results of the AuthHelper.HashPassword
type AuthHelperMockHashPasswordResults struct {
	s1  string
	err error
}

// AuthHelperMockHashPasswordOrigins contains origins of expectations of the AuthHelper.HashPassword
type AuthHelperMockHashPasswordExpectationOrigins struct {
	origin         string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHashPassword *mAuthHelperMockHashPassword) Optional() *mAuthHelperMockHashPassword {
	mmHashPassword.optional = true
	return mmHashPassword
}

// Expect sets up expected params for AuthHelper.HashPassword
func (mmHashPassword *mAuthHelperMockHashPassword) Expect(password string) *mAuthHelperMockHashPassword {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("AuthHelperMock.HashPassword mock is already set by Set")
	}

	if mmHashPassword.defaultExpectation == nil {
		mmHashPassword.defaultExpectation = &AuthHelperMockHashPasswordExpectation{}
	}

	if mmHashPassword.defaultExpectation.paramPtrs != nil {
		mmHashPassword.mock.t.Fatalf("AuthHelperMock.HashPassword mock is already set by ExpectParams functions")
	}

	mmHashPassword.defaultExpectation.params = &AuthHelperMockHashPasswordParams{password}
	mmHashPassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHashPassword.expectations {
		if minimock.Equal(e.params, mmHashPassword.defaultExpectation.params) {
			mmHashPassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHashPassword.defaultExpectation.params)
		}
	}

	return mmHashPassword
}

// ExpectPasswordParam1 sets up expected param password for AuthHelper.HashPassword
func (mmHashPassword *mAuthHelperMockHashPassword) ExpectPasswordParam1(password string) *mAuthHelperMockHashPassword {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("AuthHelperMock.HashPassword mock is already set by Set")
	}

	if mmHashPassword.defaultExpectation == nil {
		mmHashPassword.defaultExpectation = &AuthHelperMockHashPasswordExpectation{}
	}

	if mmHashPassword.defaultExpectation.params != nil {
		mmHashPassword.mock.t.Fatalf("AuthHelperMock.HashPassword mock is already set by Expect")
	}

	if mmHashPassword.defaultExpectation.paramPtrs == nil {
		mmHashPassword.defaultExpectation.paramPtrs = &AuthHelperMockHashPasswordParamPtrs{}
	}
	mmHashPassword.defaultExpectation.paramPtrs.password = &password
	mmHashPassword.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmHashPassword
}

// Inspect accepts an inspector function that has same arguments as the AuthHelper.HashPassword
func (mmHashPassword *mAuthHelperMockHashPassword) Inspect(f func(password string)) *mAuthHelperMockHashPassword {
	if mmHashPassword.mock.inspectFuncHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("Inspect function is already set for AuthHelperMock.HashPassword")
	}

	mmHashPassword.mock.inspectFuncHashPassword = f

	return mmHashPassword
}

// Return sets up results that will be returned by AuthHelper.HashPassword
func (mmHashPassword *mAuthHelperMockHashPassword) Return(s1 string, err error) *AuthHelperMock {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("AuthHelperMock.HashPassword mock is already set by Set")
	}

	if mmHashPassword.defaultExpectation == nil {
		mmHashPassword.defaultExpectation = &AuthHelperMockHashPasswordExpectation{mock: mmHashPassword.mock}
	}
	mmHashPassword.defaultExpectation.results = &AuthHelperMockHashPasswordResults{s1, err}
	mmHashPassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHashPassword.mock
}

// Set uses given function f to mock the AuthHelper.HashPassword method
func (mmHashPassword *mAuthHelperMockHashPassword) Set(f func(password string) (s1 string, err error)) *AuthHelperMock {
	if mmHashPassword.defaultExpectation != nil {
		mmHashPassword.mock.t.Fatalf("Default expectation is already set for the AuthHelper.HashPassword method")
	}

	if len(mmHashPassword.expectations) > 0 {
		mmHashPassword.mock.t.Fatalf("Some expectations are already set for the AuthHelper.HashPassword method")
	}

	mmHashPassword.mock.funcHashPassword = f
	mmHashPassword.mock.funcHashPasswordOrigin = minimock.CallerInfo(1)
	return mmHashPassword.mock
}

// When sets expectation for the AuthHelper.HashPassword which will trigger the result defined by the following
// Then helper
func (mmHashPassword *mAuthHelperMockHashPassword) When(password string) *AuthHelperMockHashPasswordExpectation {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("AuthHelperMock.HashPassword mock is already set by Set")
	}

	expectation := &AuthHelperMockHashPasswordExpectation{
		mock:               mmHashPassword.mock,
		params:             &AuthHelperMockHashPasswordParams{password},
		expectationOrigins: AuthHelperMockHashPasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHashPassword.expectations = append(mmHashPassword.expectations, expectation)
	return expectation
}

// Then sets up AuthHelper.HashPassword return parameters for the expectation previously defined by the When method
func (e *AuthHelperMockHashPasswordExpectation) Then(s1 string, err error) *AuthHelperMock {
	e.results = &AuthHelperMockHashPasswordResults{s1, err}
	return e.mock
}

// Times sets number of times AuthHelper.HashPassword should be invoked
func (mmHashPassword *mAuthHelperMockHashPassword) Times(n uint64) *mAuthHelperMockHashPassword {
	if n == 0 {
		mmHashPassword.mock.t.Fatalf("Times of AuthHelperMock.HashPassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHashPassword.expectedInvocations, n)
	mmHashPassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHashPassword
}

func (mmHashPassword *mAuthHelperMockHashPassword) invocationsDone() bool {
	if len(mmHashPassword.expectations) == 0 && mmHashPassword.defaultExpectation == nil && mmHashPassword.mock.funcHashPassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHashPassword.mock.afterHashPasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHashPassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HashPassword implements mm_auth_helper.AuthHelper
func (mmHashPassword *AuthHelperMock) HashPassword(password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmHashPassword.beforeHashPasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmHashPassword.afterHashPasswordCounter, 1)

	mmHashPassword.t.Helper()

	if mmHashPassword.inspectFuncHashPassword != nil {
		mmHashPassword.inspectFuncHashPassword(password)
	}

	mm_params := AuthHelperMockHashPasswordParams{password}

	// Record call args
	mmHashPassword.HashPasswordMock.mutex.Lock()
	mmHashPassword.HashPasswordMock.callArgs = append(mmHashPassword.HashPasswordMock.callArgs, &mm_params)
	mmHashPassword.HashPasswordMock.mutex.Unlock()

	for _, e := range mmHashPassword.HashPasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmHashPassword.HashPasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHashPassword.HashPasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmHashPassword.HashPasswordMock.defaultExpectation.params
		mm_want_ptrs := mmHashPassword.HashPasswordMock.defaultExpectation.paramPtrs

		mm_got := AuthHelperMockHashPasswordParams{password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmHashPassword.t.Errorf("AuthHelperMock.HashPassword got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHashPassword.HashPasswordMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHashPassword.t.Errorf("AuthHelperMock.HashPassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHashPassword.HashPasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHashPassword.HashPasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmHashPassword.t.Fatal("No results are set for the AuthHelperMock.HashPassword")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmHashPassword.funcHashPassword != nil {
		return mmHashPassword.funcHashPassword(password)
	}
	mmHashPassword.t.Fatalf("Unexpected call to AuthHelperMock.HashPassword. %v", password)
	return
}

// HashPasswordAfterCounter returns a count of finished AuthHelperMock.HashPassword invocations
func (mmHashPassword *AuthHelperMock) HashPasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashPassword.afterHashPasswordCounter)
}

// HashPasswordBeforeCounter returns a count of AuthHelperMock.HashPassword invocations
func (mmHashPassword *AuthHelperMock) HashPasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashPassword.beforeHashPasswordCounter)
}

// Calls returns a list of arguments used in each call to AuthHelperMock.HashPassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHashPassword *mAuthHelperMockHashPassword) Calls() []*AuthHelperMockHashPasswordParams {
	mmHashPassword.mutex.RLock()

	argCopy := make([]*AuthHelperMockHashPasswordParams, len(mmHashPassword.callArgs))
	copy(argCopy, mmHashPassword.callArgs)

	mmHashPassword.mutex.RUnlock()

	return argCopy
}

// MinimockHashPasswordDone returns true if the count of the HashPassword invocations corresponds
// the number of defined expectations
func (m *AuthHelperMock) MinimockHashPasswordDone() bool {
	if m.HashPasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashPasswordMock.invocationsDone()
}

// MinimockHashPasswordInspect logs each unmet expectation
func (m *AuthHelperMock) MinimockHashPasswordInspect() {
	for _, e := range m.HashPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHelperMock.HashPassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHashPasswordCounter := mm_atomic.LoadUint64(&m.afterHashPasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashPasswordMock.defaultExpectation != nil && afterHashPasswordCounter < 1 {
		if m.HashPasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHelperMock.HashPassword at\n%s", m.HashPasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHelperMock.HashPassword at\n%s with params: %#v", m.HashPasswordMock.defaultExpectation.expectationOrigins.origin, *m.HashPasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashPassword != nil && afterHashPasswordCounter < 1 {
		m.t.Errorf("Expected call to AuthHelperMock.HashPassword at\n%s", m.funcHashPasswordOrigin)
	}

	if !m.HashPasswordMock.invocationsDone() && afterHashPasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHelperMock.HashPassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HashPasswordMock.expectedInvocations), m.HashPasswordMock.expectedInvocationsOrigin, afterHashPasswordCounter)
	}
}

type mAuthHelperMockValidatePassword struct {
	optional           bool
	mock               *AuthHelperMock
	defaultExpectation *AuthHelperMockValidatePasswordExpectation
	expectations       []*AuthHelperMockValidatePasswordExpectation

	callArgs []*AuthHelperMockValidatePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHelperMockValidatePasswordExpectation specifies expectation struct of the AuthHelper.ValidatePassword
type AuthHelperMockValidatePasswordExpectation struct {
	mock               *AuthHelperMock
	params             *AuthHelperMockValidatePasswordParams
	paramPtrs          *AuthHelperMockValidatePasswordParamPtrs
	expectationOrigins AuthHelperMockValidatePasswordExpectationOrigins
	results            *AuthHelperMockValidatePasswordResults
	returnOrigin       string
	Counter            uint64
}

// AuthHelperMockValidatePasswordParams contains parameters of the AuthHelper.ValidatePassword
type AuthHelperMockValidatePasswordParams struct {
	hashedPassword    string
	candidatePassword string
}

// AuthHelperMockValidatePasswordParamPtrs contains pointers to parameters of the AuthHelper.ValidatePassword
type AuthHelperMockValidatePasswordParamPtrs struct {
	hashedPassword    *string
	candidatePassword *string
}

// AuthHelperMockValidatePasswordResults contains results of the AuthHelper.ValidatePassword
type AuthHelperMockValidatePasswordResults struct {
	b1 bool
}

// AuthHelperMockValidatePasswordOrigins contains origins of expectations of the AuthHelper.ValidatePassword
type AuthHelperMockValidatePasswordExpectationOrigins struct {
	origin                  string
	originHashedPassword    string
	originCandidatePassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidatePassword *mAuthHelperMockValidatePassword) Optional() *mAuthHelperMockValidatePassword {
	mmValidatePassword.optional = true
	return mmValidatePassword
}

// Expect sets up expected params for AuthHelper.ValidatePassword
func (mmValidatePassword *mAuthHelperMockValidatePassword) Expect(hashedPassword string, candidatePassword string) *mAuthHelperMockValidatePassword {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by Set")
	}

	if mmValidatePassword.defaultExpectation == nil {
		mmValidatePassword.defaultExpectation = &AuthHelperMockValidatePasswordExpectation{}
	}

	if mmValidatePassword.defaultExpectation.paramPtrs != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by ExpectParams functions")
	}

	mmValidatePassword.defaultExpectation.params = &AuthHelperMockValidatePasswordParams{hashedPassword, candidatePassword}
	mmValidatePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidatePassword.expectations {
		if minimock.Equal(e.params, mmValidatePassword.defaultExpectation.params) {
			mmValidatePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidatePassword.defaultExpectation.params)
		}
	}

	return mmValidatePassword
}

// ExpectHashedPasswordParam1 sets up expected param hashedPassword for AuthHelper.ValidatePassword
func (mmValidatePassword *mAuthHelperMockValidatePassword) ExpectHashedPasswordParam1(hashedPassword string) *mAuthHelperMockValidatePassword {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by Set")
	}

	if mmValidatePassword.defaultExpectation == nil {
		mmValidatePassword.defaultExpectation = &AuthHelperMockValidatePasswordExpectation{}
	}

	if mmValidatePassword.defaultExpectation.params != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by Expect")
	}

	if mmValidatePassword.defaultExpectation.paramPtrs == nil {
		mmValidatePassword.defaultExpectation.paramPtrs = &AuthHelperMockValidatePasswordParamPtrs{}
	}
	mmValidatePassword.defaultExpectation.paramPtrs.hashedPassword = &hashedPassword
	mmValidatePassword.defaultExpectation.expectationOrigins.originHashedPassword = minimock.CallerInfo(1)

	return mmValidatePassword
}

// ExpectCandidatePasswordParam2 sets up expected param candidatePassword for AuthHelper.ValidatePassword
func (mmValidatePassword *mAuthHelperMockValidatePassword) ExpectCandidatePasswordParam2(candidatePassword string) *mAuthHelperMockValidatePassword {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by Set")
	}

	if mmValidatePassword.defaultExpectation == nil {
		mmValidatePassword.defaultExpectation = &AuthHelperMockValidatePasswordExpectation{}
	}

	if mmValidatePassword.defaultExpectation.params != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by Expect")
	}

	if mmValidatePassword.defaultExpectation.paramPtrs == nil {
		mmValidatePassword.defaultExpectation.paramPtrs = &AuthHelperMockValidatePasswordParamPtrs{}
	}
	mmValidatePassword.defaultExpectation.paramPtrs.candidatePassword = &candidatePassword
	mmValidatePassword.defaultExpectation.expectationOrigins.originCandidatePassword = minimock.CallerInfo(1)

	return mmValidatePassword
}

// Inspect accepts an inspector function that has same arguments as the AuthHelper.ValidatePassword
func (mmValidatePassword *mAuthHelperMockValidatePassword) Inspect(f func(hashedPassword string, candidatePassword string)) *mAuthHelperMockValidatePassword {
	if mmValidatePassword.mock.inspectFuncValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("Inspect function is already set for AuthHelperMock.ValidatePassword")
	}

	mmValidatePassword.mock.inspectFuncValidatePassword = f

	return mmValidatePassword
}

// Return sets up results that will be returned by AuthHelper.ValidatePassword
func (mmValidatePassword *mAuthHelperMockValidatePassword) Return(b1 bool) *AuthHelperMock {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by Set")
	}

	if mmValidatePassword.defaultExpectation == nil {
		mmValidatePassword.defaultExpectation = &AuthHelperMockValidatePasswordExpectation{mock: mmValidatePassword.mock}
	}
	mmValidatePassword.defaultExpectation.results = &AuthHelperMockValidatePasswordResults{b1}
	mmValidatePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidatePassword.mock
}

// Set uses given function f to mock the AuthHelper.ValidatePassword method
func (mmValidatePassword *mAuthHelperMockValidatePassword) Set(f func(hashedPassword string, candidatePassword string) (b1 bool)) *AuthHelperMock {
	if mmValidatePassword.defaultExpectation != nil {
		mmValidatePassword.mock.t.Fatalf("Default expectation is already set for the AuthHelper.ValidatePassword method")
	}

	if len(mmValidatePassword.expectations) > 0 {
		mmValidatePassword.mock.t.Fatalf("Some expectations are already set for the AuthHelper.ValidatePassword method")
	}

	mmValidatePassword.mock.funcValidatePassword = f
	mmValidatePassword.mock.funcValidatePasswordOrigin = minimock.CallerInfo(1)
	return mmValidatePassword.mock
}

// When sets expectation for the AuthHelper.ValidatePassword which will trigger the result defined by the following
// Then helper
func (mmValidatePassword *mAuthHelperMockValidatePassword) When(hashedPassword string, candidatePassword string) *AuthHelperMockValidatePasswordExpectation {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("AuthHelperMock.ValidatePassword mock is already set by Set")
	}

	expectation := &AuthHelperMockValidatePasswordExpectation{
		mock:               mmValidatePassword.mock,
		params:             &AuthHelperMockValidatePasswordParams{hashedPassword, candidatePassword},
		expectationOrigins: AuthHelperMockValidatePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidatePassword.expectations = append(mmValidatePassword.expectations, expectation)
	return expectation
}

// Then sets up AuthHelper.ValidatePassword return parameters for the expectation previously defined by the When method
func (e *AuthHelperMockValidatePasswordExpectation) Then(b1 bool) *AuthHelperMock {
	e.results = &AuthHelperMockValidatePasswordResults{b1}
	return e.mock
}

// Times sets number of times AuthHelper.ValidatePassword should be invoked
func (mmValidatePassword *mAuthHelperMockValidatePassword) Times(n uint64) *mAuthHelperMockValidatePassword {
	if n == 0 {
		mmValidatePassword.mock.t.Fatalf("Times of AuthHelperMock.ValidatePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidatePassword.expectedInvocations, n)
	mmValidatePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidatePassword
}

func (mmValidatePassword *mAuthHelperMockValidatePassword) invocationsDone() bool {
	if len(mmValidatePassword.expectations) == 0 && mmValidatePassword.defaultExpectation == nil && mmValidatePassword.mock.funcValidatePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidatePassword.mock.afterValidatePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidatePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidatePassword implements mm_auth_helper.AuthHelper
func (mmValidatePassword *AuthHelperMock) ValidatePassword(hashedPassword string, candidatePassword string) (b1 bool) {
	mm_atomic.AddUint64(&mmValidatePassword.beforeValidatePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmValidatePassword.afterValidatePasswordCounter, 1)

	mmValidatePassword.t.Helper()

	if mmValidatePassword.inspectFuncValidatePassword != nil {
		mmValidatePassword.inspectFuncValidatePassword(hashedPassword, candidatePassword)
	}

	mm_params := AuthHelperMockValidatePasswordParams{hashedPassword, candidatePassword}

	// Record call args
	mmValidatePassword.ValidatePasswordMock.mutex.Lock()
	mmValidatePassword.ValidatePasswordMock.callArgs = append(mmValidatePassword.ValidatePasswordMock.callArgs, &mm_params)
	mmValidatePassword.ValidatePasswordMock.mutex.Unlock()

	for _, e := range mmValidatePassword.ValidatePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmValidatePassword.ValidatePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidatePassword.ValidatePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmValidatePassword.ValidatePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmValidatePassword.ValidatePasswordMock.defaultExpectation.paramPtrs

		mm_got := AuthHelperMockValidatePasswordParams{hashedPassword, candidatePassword}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.hashedPassword != nil && !minimock.Equal(*mm_want_ptrs.hashedPassword, mm_got.hashedPassword) {
				mmValidatePassword.t.Errorf("AuthHelperMock.ValidatePassword got unexpected parameter hashedPassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidatePassword.ValidatePasswordMock.defaultExpectation.expectationOrigins.originHashedPassword, *mm_want_ptrs.hashedPassword, mm_got.hashedPassword, minimock.Diff(*mm_want_ptrs.hashedPassword, mm_got.hashedPassword))
			}

			if mm_want_ptrs.candidatePassword != nil && !minimock.Equal(*mm_want_ptrs.candidatePassword, mm_got.candidatePassword) {
				mmValidatePassword.t.Errorf("AuthHelperMock.ValidatePassword got unexpected parameter candidatePassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidatePassword.ValidatePasswordMock.defaultExpectation.expectationOrigins.originCandidatePassword, *mm_want_ptrs.candidatePassword, mm_got.candidatePassword, minimock.Diff(*mm_want_ptrs.candidatePassword, mm_got.candidatePassword))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidatePassword.t.Errorf("AuthHelperMock.ValidatePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidatePassword.ValidatePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidatePassword.ValidatePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmValidatePassword.t.Fatal("No results are set for the AuthHelperMock.ValidatePassword")
		}
		return (*mm_results).b1
	}
	if mmValidatePassword.funcValidatePassword != nil {
		return mmValidatePassword.funcValidatePassword(hashedPassword, candidatePassword)
	}
	mmValidatePassword.t.Fatalf("Unexpected call to AuthHelperMock.ValidatePassword. %v %v", hashedPassword, candidatePassword)
	return
}

// ValidatePasswordAfterCounter returns a count of finished AuthHelperMock.ValidatePassword invocations
func (mmValidatePassword *AuthHelperMock) ValidatePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePassword.afterValidatePasswordCounter)
}

// ValidatePasswordBeforeCounter returns a count of AuthHelperMock.ValidatePassword invocations
func (mmValidatePassword *AuthHelperMock) ValidatePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePassword.beforeValidatePasswordCounter)
}

// Calls returns a list of arguments used in each call to AuthHelperMock.ValidatePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidatePassword *mAuthHelperMockValidatePassword) Calls() []*AuthHelperMockValidatePasswordParams {
	mmValidatePassword.mutex.RLock()

	argCopy := make([]*AuthHelperMockValidatePasswordParams, len(mmValidatePassword.callArgs))
	copy(argCopy, mmValidatePassword.callArgs)

	mmValidatePassword.mutex.RUnlock()

	return argCopy
}

// MinimockValidatePasswordDone returns true if the count of the ValidatePassword invocations corresponds
// the number of defined expectations
func (m *AuthHelperMock) MinimockValidatePasswordDone() bool {
	if m.ValidatePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidatePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidatePasswordMock.invocationsDone()
}

// MinimockValidatePasswordInspect logs each unmet expectation
func (m *AuthHelperMock) MinimockValidatePasswordInspect() {
	for _, e := range m.ValidatePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHelperMock.ValidatePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidatePasswordCounter := mm_atomic.LoadUint64(&m.afterValidatePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidatePasswordMock.defaultExpectation != nil && afterValidatePasswordCounter < 1 {
		if m.ValidatePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHelperMock.ValidatePassword at\n%s", m.ValidatePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHelperMock.ValidatePassword at\n%s with params: %#v", m.ValidatePasswordMock.defaultExpectation.expectationOrigins.origin, *m.ValidatePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidatePassword != nil && afterValidatePasswordCounter < 1 {
		m.t.Errorf("Expected call to AuthHelperMock.ValidatePassword at\n%s", m.funcValidatePasswordOrigin)
	}

	if !m.ValidatePasswordMock.invocationsDone() && afterValidatePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHelperMock.ValidatePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidatePasswordMock.expectedInvocations), m.ValidatePasswordMock.expectedInvocationsOrigin, afterValidatePasswordCounter)
	}
}

type mAuthHelperMockVerifyToken struct {
	optional           bool
	mock               *AuthHelperMock
	defaultExpectation *AuthHelperMockVerifyTokenExpectation
	expectations       []*AuthHelperMockVerifyTokenExpectation

	callArgs []*AuthHelperMockVerifyTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthHelperMockVerifyTokenExpectation specifies expectation struct of the AuthHelper.VerifyToken
type AuthHelperMockVerifyTokenExpectation struct {
	mock               *AuthHelperMock
	params             *AuthHelperMockVerifyTokenParams
	paramPtrs          *AuthHelperMockVerifyTokenParamPtrs
	expectationOrigins AuthHelperMockVerifyTokenExpectationOrigins
	results            *AuthHelperMockVerifyTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthHelperMockVerifyTokenParams contains parameters of the AuthHelper.VerifyToken
type AuthHelperMockVerifyTokenParams struct {
	token string
}

// AuthHelperMockVerifyTokenParamPtrs contains pointers to parameters of the AuthHelper.VerifyToken
type AuthHelperMockVerifyTokenParamPtrs struct {
	token *string
}

// AuthHelperMockVerifyTokenResults contains results of the AuthHelper.VerifyToken
type AuthHelperMockVerifyTokenResults struct {
	up1 *model.UserClaims
	err error
}

// AuthHelperMockVerifyTokenOrigins contains origins of expectations of the AuthHelper.VerifyToken
type AuthHelperMockVerifyTokenExpectationOrigins struct {
	origin      string
	originToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVerifyToken *mAuthHelperMockVerifyToken) Optional() *mAuthHelperMockVerifyToken {
	mmVerifyToken.optional = true
	return mmVerifyToken
}

// Expect sets up expected params for AuthHelper.VerifyToken
func (mmVerifyToken *mAuthHelperMockVerifyToken) Expect(token string) *mAuthHelperMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("AuthHelperMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &AuthHelperMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.paramPtrs != nil {
		mmVerifyToken.mock.t.Fatalf("AuthHelperMock.VerifyToken mock is already set by ExpectParams functions")
	}

	mmVerifyToken.defaultExpectation.params = &AuthHelperMockVerifyTokenParams{token}
	mmVerifyToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVerifyToken.expectations {
		if minimock.Equal(e.params, mmVerifyToken.defaultExpectation.params) {
			mmVerifyToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyToken.defaultExpectation.params)
		}
	}

	return mmVerifyToken
}

// ExpectTokenParam1 sets up expected param token for AuthHelper.VerifyToken
func (mmVerifyToken *mAuthHelperMockVerifyToken) ExpectTokenParam1(token string) *mAuthHelperMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("AuthHelperMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &AuthHelperMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.params != nil {
		mmVerifyToken.mock.t.Fatalf("AuthHelperMock.VerifyToken mock is already set by Expect")
	}

	if mmVerifyToken.defaultExpectation.paramPtrs == nil {
		mmVerifyToken.defaultExpectation.paramPtrs = &AuthHelperMockVerifyTokenParamPtrs{}
	}
	mmVerifyToken.defaultExpectation.paramPtrs.token = &token
	mmVerifyToken.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmVerifyToken
}

// Inspect accepts an inspector function that has same arguments as the AuthHelper.VerifyToken
func (mmVerifyToken *mAuthHelperMockVerifyToken) Inspect(f func(token string)) *mAuthHelperMockVerifyToken {
	if mmVerifyToken.mock.inspectFuncVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("Inspect function is already set for AuthHelperMock.VerifyToken")
	}

	mmVerifyToken.mock.inspectFuncVerifyToken = f

	return mmVerifyToken
}

// Return sets up results that will be returned by AuthHelper.VerifyToken
func (mmVerifyToken *mAuthHelperMockVerifyToken) Return(up1 *model.UserClaims, err error) *AuthHelperMock {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("AuthHelperMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &AuthHelperMockVerifyTokenExpectation{mock: mmVerifyToken.mock}
	}
	mmVerifyToken.defaultExpectation.results = &AuthHelperMockVerifyTokenResults{up1, err}
	mmVerifyToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVerifyToken.mock
}

// Set uses given function f to mock the AuthHelper.VerifyToken method
func (mmVerifyToken *mAuthHelperMockVerifyToken) Set(f func(token string) (up1 *model.UserClaims, err error)) *AuthHelperMock {
	if mmVerifyToken.defaultExpectation != nil {
		mmVerifyToken.mock.t.Fatalf("Default expectation is already set for the AuthHelper.VerifyToken method")
	}

	if len(mmVerifyToken.expectations) > 0 {
		mmVerifyToken.mock.t.Fatalf("Some expectations are already set for the AuthHelper.VerifyToken method")
	}

	mmVerifyToken.mock.funcVerifyToken = f
	mmVerifyToken.mock.funcVerifyTokenOrigin = minimock.CallerInfo(1)
	return mmVerifyToken.mock
}

// When sets expectation for the AuthHelper.VerifyToken which will trigger the result defined by the following
// Then helper
func (mmVerifyToken *mAuthHelperMockVerifyToken) When(token string) *AuthHelperMockVerifyTokenExpectation {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("AuthHelperMock.VerifyToken mock is already set by Set")
	}

	expectation := &AuthHelperMockVerifyTokenExpectation{
		mock:               mmVerifyToken.mock,
		params:             &AuthHelperMockVerifyTokenParams{token},
		expectationOrigins: AuthHelperMockVerifyTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVerifyToken.expectations = append(mmVerifyToken.expectations, expectation)
	return expectation
}

// Then sets up AuthHelper.VerifyToken return parameters for the expectation previously defined by the When method
func (e *AuthHelperMockVerifyTokenExpectation) Then(up1 *model.UserClaims, err error) *AuthHelperMock {
	e.results = &AuthHelperMockVerifyTokenResults{up1, err}
	return e.mock
}

// Times sets number of times AuthHelper.VerifyToken should be invoked
func (mmVerifyToken *mAuthHelperMockVerifyToken) Times(n uint64) *mAuthHelperMockVerifyToken {
	if n == 0 {
		mmVerifyToken.mock.t.Fatalf("Times of AuthHelperMock.VerifyToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVerifyToken.expectedInvocations, n)
	mmVerifyToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVerifyToken
}

func (mmVerifyToken *mAuthHelperMockVerifyToken) invocationsDone() bool {
	if len(mmVerifyToken.expectations) == 0 && mmVerifyToken.defaultExpectation == nil && mmVerifyToken.mock.funcVerifyToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVerifyToken.mock.afterVerifyTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVerifyToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VerifyToken implements mm_auth_helper.AuthHelper
func (mmVerifyToken *AuthHelperMock) VerifyToken(token string) (up1 *model.UserClaims, err error) {
	mm_atomic.AddUint64(&mmVerifyToken.beforeVerifyTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyToken.afterVerifyTokenCounter, 1)

	mmVerifyToken.t.Helper()

	if mmVerifyToken.inspectFuncVerifyToken != nil {
		mmVerifyToken.inspectFuncVerifyToken(token)
	}

	mm_params := AuthHelperMockVerifyTokenParams{token}

	// Record call args
	mmVerifyToken.VerifyTokenMock.mutex.Lock()
	mmVerifyToken.VerifyTokenMock.callArgs = append(mmVerifyToken.VerifyTokenMock.callArgs, &mm_params)
	mmVerifyToken.VerifyTokenMock.mutex.Unlock()

	for _, e := range mmVerifyToken.VerifyTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmVerifyToken.VerifyTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyToken.VerifyTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyToken.VerifyTokenMock.defaultExpectation.params
		mm_want_ptrs := mmVerifyToken.VerifyTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthHelperMockVerifyTokenParams{token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmVerifyToken.t.Errorf("AuthHelperMock.VerifyToken got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyToken.t.Errorf("AuthHelperMock.VerifyToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVerifyToken.VerifyTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmVerifyToken.t.Fatal("No results are set for the AuthHelperMock.VerifyToken")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmVerifyToken.funcVerifyToken != nil {
		return mmVerifyToken.funcVerifyToken(token)
	}
	mmVerifyToken.t.Fatalf("Unexpected call to AuthHelperMock.VerifyToken. %v", token)
	return
}

// VerifyTokenAfterCounter returns a count of finished AuthHelperMock.VerifyToken invocations
func (mmVerifyToken *AuthHelperMock) VerifyTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyToken.afterVerifyTokenCounter)
}

// VerifyTokenBeforeCounter returns a count of AuthHelperMock.VerifyToken invocations
func (mmVerifyToken *AuthHelperMock) VerifyTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyToken.beforeVerifyTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthHelperMock.VerifyToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyToken *mAuthHelperMockVerifyToken) Calls() []*AuthHelperMockVerifyTokenParams {
	mmVerifyToken.mutex.RLock()

	argCopy := make([]*AuthHelperMockVerifyTokenParams, len(mmVerifyToken.callArgs))
	copy(argCopy, mmVerifyToken.callArgs)

	mmVerifyToken.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyTokenDone returns true if the count of the VerifyToken invocations corresponds
// the number of defined expectations
func (m *AuthHelperMock) MinimockVerifyTokenDone() bool {
	if m.VerifyTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VerifyTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VerifyTokenMock.invocationsDone()
}

// MinimockVerifyTokenInspect logs each unmet expectation
func (m *AuthHelperMock) MinimockVerifyTokenInspect() {
	for _, e := range m.VerifyTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthHelperMock.VerifyToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVerifyTokenCounter := mm_atomic.LoadUint64(&m.afterVerifyTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyTokenMock.defaultExpectation != nil && afterVerifyTokenCounter < 1 {
		if m.VerifyTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthHelperMock.VerifyToken at\n%s", m.VerifyTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthHelperMock.VerifyToken at\n%s with params: %#v", m.VerifyTokenMock.defaultExpectation.expectationOrigins.origin, *m.VerifyTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyToken != nil && afterVerifyTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthHelperMock.VerifyToken at\n%s", m.funcVerifyTokenOrigin)
	}

	if !m.VerifyTokenMock.invocationsDone() && afterVerifyTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthHelperMock.VerifyToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VerifyTokenMock.expectedInvocations), m.VerifyTokenMock.expectedInvocationsOrigin, afterVerifyTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthHelperMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGenerateAccessTokenInspect()

			m.MinimockGenerateRefreshTokenInspect()

			m.MinimockHashPasswordInspect()

			m.MinimockValidatePasswordInspect()

			m.MinimockVerifyTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthHelperMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthHelperMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateAccessTokenDone() &&
		m.MinimockGenerateRefreshTokenDone() &&
		m.MinimockHashPasswordDone() &&
		m.MinimockValidatePasswordDone() &&
		m.MinimockVerifyTokenDone()
}

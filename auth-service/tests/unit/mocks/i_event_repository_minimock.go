// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/events.IEventRepository -o i_event_repository_minimock.go -n IEventRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
	"github.com/gojuno/minimock/v3"
)

// IEventRepositoryMock implements mm_events.IEventRepository
type IEventRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCompleteEvents          func(ctx context.Context, completeIDs []int) (err error)
	funcCompleteEventsOrigin    string
	inspectFuncCompleteEvents   func(ctx context.Context, completeIDs []int)
	afterCompleteEventsCounter  uint64
	beforeCompleteEventsCounter uint64
	CompleteEventsMock          mIEventRepositoryMockCompleteEvents

	funcGetEvents          func(ctx context.Context) (ea1 []model.EventData, err error)
	funcGetEventsOrigin    string
	inspectFuncGetEvents   func(ctx context.Context)
	afterGetEventsCounter  uint64
	beforeGetEventsCounter uint64
	GetEventsMock          mIEventRepositoryMockGetEvents

	funcSendEvent          func(ctx context.Context, event *model.SendEvent) (err error)
	funcSendEventOrigin    string
	inspectFuncSendEvent   func(ctx context.Context, event *model.SendEvent)
	afterSendEventCounter  uint64
	beforeSendEventCounter uint64
	SendEventMock          mIEventRepositoryMockSendEvent
}

// NewIEventRepositoryMock returns a mock for mm_events.IEventRepository
func NewIEventRepositoryMock(t minimock.Tester) *IEventRepositoryMock {
	m := &IEventRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CompleteEventsMock = mIEventRepositoryMockCompleteEvents{mock: m}
	m.CompleteEventsMock.callArgs = []*IEventRepositoryMockCompleteEventsParams{}

	m.GetEventsMock = mIEventRepositoryMockGetEvents{mock: m}
	m.GetEventsMock.callArgs = []*IEventRepositoryMockGetEventsParams{}

	m.SendEventMock = mIEventRepositoryMockSendEvent{mock: m}
	m.SendEventMock.callArgs = []*IEventRepositoryMockSendEventParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIEventRepositoryMockCompleteEvents struct {
	optional           bool
	mock               *IEventRepositoryMock
	defaultExpectation *IEventRepositoryMockCompleteEventsExpectation
	expectations       []*IEventRepositoryMockCompleteEventsExpectation

	callArgs []*IEventRepositoryMockCompleteEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IEventRepositoryMockCompleteEventsExpectation specifies expectation struct of the IEventRepository.CompleteEvents
type IEventRepositoryMockCompleteEventsExpectation struct {
	mock               *IEventRepositoryMock
	params             *IEventRepositoryMockCompleteEventsParams
	paramPtrs          *IEventRepositoryMockCompleteEventsParamPtrs
	expectationOrigins IEventRepositoryMockCompleteEventsExpectationOrigins
	results            *IEventRepositoryMockCompleteEventsResults
	returnOrigin       string
	Counter            uint64
}

// IEventRepositoryMockCompleteEventsParams contains parameters of the IEventRepository.CompleteEvents
type IEventRepositoryMockCompleteEventsParams struct {
	ctx         context.Context
	completeIDs []int
}

// IEventRepositoryMockCompleteEventsParamPtrs contains pointers to parameters of the IEventRepository.CompleteEvents
type IEventRepositoryMockCompleteEventsParamPtrs struct {
	ctx         *context.Context
	completeIDs *[]int
}

// IEventRepositoryMockCompleteEventsResults contains results of the IEventRepository.CompleteEvents
type IEventRepositoryMockCompleteEventsResults struct {
	err error
}

// IEventRepositoryMockCompleteEventsOrigins contains origins of expectations of the IEventRepository.CompleteEvents
type IEventRepositoryMockCompleteEventsExpectationOrigins struct {
	origin            string
	originCtx         string
	originCompleteIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) Optional() *mIEventRepositoryMockCompleteEvents {
	mmCompleteEvents.optional = true
	return mmCompleteEvents
}

// Expect sets up expected params for IEventRepository.CompleteEvents
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) Expect(ctx context.Context, completeIDs []int) *mIEventRepositoryMockCompleteEvents {
	if mmCompleteEvents.mock.funcCompleteEvents != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by Set")
	}

	if mmCompleteEvents.defaultExpectation == nil {
		mmCompleteEvents.defaultExpectation = &IEventRepositoryMockCompleteEventsExpectation{}
	}

	if mmCompleteEvents.defaultExpectation.paramPtrs != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by ExpectParams functions")
	}

	mmCompleteEvents.defaultExpectation.params = &IEventRepositoryMockCompleteEventsParams{ctx, completeIDs}
	mmCompleteEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCompleteEvents.expectations {
		if minimock.Equal(e.params, mmCompleteEvents.defaultExpectation.params) {
			mmCompleteEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompleteEvents.defaultExpectation.params)
		}
	}

	return mmCompleteEvents
}

// ExpectCtxParam1 sets up expected param ctx for IEventRepository.CompleteEvents
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) ExpectCtxParam1(ctx context.Context) *mIEventRepositoryMockCompleteEvents {
	if mmCompleteEvents.mock.funcCompleteEvents != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by Set")
	}

	if mmCompleteEvents.defaultExpectation == nil {
		mmCompleteEvents.defaultExpectation = &IEventRepositoryMockCompleteEventsExpectation{}
	}

	if mmCompleteEvents.defaultExpectation.params != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by Expect")
	}

	if mmCompleteEvents.defaultExpectation.paramPtrs == nil {
		mmCompleteEvents.defaultExpectation.paramPtrs = &IEventRepositoryMockCompleteEventsParamPtrs{}
	}
	mmCompleteEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmCompleteEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCompleteEvents
}

// ExpectCompleteIDsParam2 sets up expected param completeIDs for IEventRepository.CompleteEvents
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) ExpectCompleteIDsParam2(completeIDs []int) *mIEventRepositoryMockCompleteEvents {
	if mmCompleteEvents.mock.funcCompleteEvents != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by Set")
	}

	if mmCompleteEvents.defaultExpectation == nil {
		mmCompleteEvents.defaultExpectation = &IEventRepositoryMockCompleteEventsExpectation{}
	}

	if mmCompleteEvents.defaultExpectation.params != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by Expect")
	}

	if mmCompleteEvents.defaultExpectation.paramPtrs == nil {
		mmCompleteEvents.defaultExpectation.paramPtrs = &IEventRepositoryMockCompleteEventsParamPtrs{}
	}
	mmCompleteEvents.defaultExpectation.paramPtrs.completeIDs = &completeIDs
	mmCompleteEvents.defaultExpectation.expectationOrigins.originCompleteIDs = minimock.CallerInfo(1)

	return mmCompleteEvents
}

// Inspect accepts an inspector function that has same arguments as the IEventRepository.CompleteEvents
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) Inspect(f func(ctx context.Context, completeIDs []int)) *mIEventRepositoryMockCompleteEvents {
	if mmCompleteEvents.mock.inspectFuncCompleteEvents != nil {
		mmCompleteEvents.mock.t.Fatalf("Inspect function is already set for IEventRepositoryMock.CompleteEvents")
	}

	mmCompleteEvents.mock.inspectFuncCompleteEvents = f

	return mmCompleteEvents
}

// Return sets up results that will be returned by IEventRepository.CompleteEvents
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) Return(err error) *IEventRepositoryMock {
	if mmCompleteEvents.mock.funcCompleteEvents != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by Set")
	}

	if mmCompleteEvents.defaultExpectation == nil {
		mmCompleteEvents.defaultExpectation = &IEventRepositoryMockCompleteEventsExpectation{mock: mmCompleteEvents.mock}
	}
	mmCompleteEvents.defaultExpectation.results = &IEventRepositoryMockCompleteEventsResults{err}
	mmCompleteEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCompleteEvents.mock
}

// Set uses given function f to mock the IEventRepository.CompleteEvents method
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) Set(f func(ctx context.Context, completeIDs []int) (err error)) *IEventRepositoryMock {
	if mmCompleteEvents.defaultExpectation != nil {
		mmCompleteEvents.mock.t.Fatalf("Default expectation is already set for the IEventRepository.CompleteEvents method")
	}

	if len(mmCompleteEvents.expectations) > 0 {
		mmCompleteEvents.mock.t.Fatalf("Some expectations are already set for the IEventRepository.CompleteEvents method")
	}

	mmCompleteEvents.mock.funcCompleteEvents = f
	mmCompleteEvents.mock.funcCompleteEventsOrigin = minimock.CallerInfo(1)
	return mmCompleteEvents.mock
}

// When sets expectation for the IEventRepository.CompleteEvents which will trigger the result defined by the following
// Then helper
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) When(ctx context.Context, completeIDs []int) *IEventRepositoryMockCompleteEventsExpectation {
	if mmCompleteEvents.mock.funcCompleteEvents != nil {
		mmCompleteEvents.mock.t.Fatalf("IEventRepositoryMock.CompleteEvents mock is already set by Set")
	}

	expectation := &IEventRepositoryMockCompleteEventsExpectation{
		mock:               mmCompleteEvents.mock,
		params:             &IEventRepositoryMockCompleteEventsParams{ctx, completeIDs},
		expectationOrigins: IEventRepositoryMockCompleteEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCompleteEvents.expectations = append(mmCompleteEvents.expectations, expectation)
	return expectation
}

// Then sets up IEventRepository.CompleteEvents return parameters for the expectation previously defined by the When method
func (e *IEventRepositoryMockCompleteEventsExpectation) Then(err error) *IEventRepositoryMock {
	e.results = &IEventRepositoryMockCompleteEventsResults{err}
	return e.mock
}

// Times sets number of times IEventRepository.CompleteEvents should be invoked
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) Times(n uint64) *mIEventRepositoryMockCompleteEvents {
	if n == 0 {
		mmCompleteEvents.mock.t.Fatalf("Times of IEventRepositoryMock.CompleteEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCompleteEvents.expectedInvocations, n)
	mmCompleteEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCompleteEvents
}

func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) invocationsDone() bool {
	if len(mmCompleteEvents.expectations) == 0 && mmCompleteEvents.defaultExpectation == nil && mmCompleteEvents.mock.funcCompleteEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCompleteEvents.mock.afterCompleteEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCompleteEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CompleteEvents implements mm_events.IEventRepository
func (mmCompleteEvents *IEventRepositoryMock) CompleteEvents(ctx context.Context, completeIDs []int) (err error) {
	mm_atomic.AddUint64(&mmCompleteEvents.beforeCompleteEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmCompleteEvents.afterCompleteEventsCounter, 1)

	mmCompleteEvents.t.Helper()

	if mmCompleteEvents.inspectFuncCompleteEvents != nil {
		mmCompleteEvents.inspectFuncCompleteEvents(ctx, completeIDs)
	}

	mm_params := IEventRepositoryMockCompleteEventsParams{ctx, completeIDs}

	// Record call args
	mmCompleteEvents.CompleteEventsMock.mutex.Lock()
	mmCompleteEvents.CompleteEventsMock.callArgs = append(mmCompleteEvents.CompleteEventsMock.callArgs, &mm_params)
	mmCompleteEvents.CompleteEventsMock.mutex.Unlock()

	for _, e := range mmCompleteEvents.CompleteEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCompleteEvents.CompleteEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompleteEvents.CompleteEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmCompleteEvents.CompleteEventsMock.defaultExpectation.params
		mm_want_ptrs := mmCompleteEvents.CompleteEventsMock.defaultExpectation.paramPtrs

		mm_got := IEventRepositoryMockCompleteEventsParams{ctx, completeIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCompleteEvents.t.Errorf("IEventRepositoryMock.CompleteEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCompleteEvents.CompleteEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.completeIDs != nil && !minimock.Equal(*mm_want_ptrs.completeIDs, mm_got.completeIDs) {
				mmCompleteEvents.t.Errorf("IEventRepositoryMock.CompleteEvents got unexpected parameter completeIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCompleteEvents.CompleteEventsMock.defaultExpectation.expectationOrigins.originCompleteIDs, *mm_want_ptrs.completeIDs, mm_got.completeIDs, minimock.Diff(*mm_want_ptrs.completeIDs, mm_got.completeIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompleteEvents.t.Errorf("IEventRepositoryMock.CompleteEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCompleteEvents.CompleteEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompleteEvents.CompleteEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmCompleteEvents.t.Fatal("No results are set for the IEventRepositoryMock.CompleteEvents")
		}
		return (*mm_results).err
	}
	if mmCompleteEvents.funcCompleteEvents != nil {
		return mmCompleteEvents.funcCompleteEvents(ctx, completeIDs)
	}
	mmCompleteEvents.t.Fatalf("Unexpected call to IEventRepositoryMock.CompleteEvents. %v %v", ctx, completeIDs)
	return
}

// CompleteEventsAfterCounter returns a count of finished IEventRepositoryMock.CompleteEvents invocations
func (mmCompleteEvents *IEventRepositoryMock) CompleteEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompleteEvents.afterCompleteEventsCounter)
}

// CompleteEventsBeforeCounter returns a count of IEventRepositoryMock.CompleteEvents invocations
func (mmCompleteEvents *IEventRepositoryMock) CompleteEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompleteEvents.beforeCompleteEventsCounter)
}

// Calls returns a list of arguments used in each call to IEventRepositoryMock.CompleteEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompleteEvents *mIEventRepositoryMockCompleteEvents) Calls() []*IEventRepositoryMockCompleteEventsParams {
	mmCompleteEvents.mutex.RLock()

	argCopy := make([]*IEventRepositoryMockCompleteEventsParams, len(mmCompleteEvents.callArgs))
	copy(argCopy, mmCompleteEvents.callArgs)

	mmCompleteEvents.mutex.RUnlock()

	return argCopy
}

// MinimockCompleteEventsDone returns true if the count of the CompleteEvents invocations corresponds
// the number of defined expectations
func (m *IEventRepositoryMock) MinimockCompleteEventsDone() bool {
	if m.CompleteEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CompleteEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CompleteEventsMock.invocationsDone()
}

// MinimockCompleteEventsInspect logs each unmet expectation
func (m *IEventRepositoryMock) MinimockCompleteEventsInspect() {
	for _, e := range m.CompleteEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEventRepositoryMock.CompleteEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCompleteEventsCounter := mm_atomic.LoadUint64(&m.afterCompleteEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CompleteEventsMock.defaultExpectation != nil && afterCompleteEventsCounter < 1 {
		if m.CompleteEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IEventRepositoryMock.CompleteEvents at\n%s", m.CompleteEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IEventRepositoryMock.CompleteEvents at\n%s with params: %#v", m.CompleteEventsMock.defaultExpectation.expectationOrigins.origin, *m.CompleteEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompleteEvents != nil && afterCompleteEventsCounter < 1 {
		m.t.Errorf("Expected call to IEventRepositoryMock.CompleteEvents at\n%s", m.funcCompleteEventsOrigin)
	}

	if !m.CompleteEventsMock.invocationsDone() && afterCompleteEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to IEventRepositoryMock.CompleteEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CompleteEventsMock.expectedInvocations), m.CompleteEventsMock.expectedInvocationsOrigin, afterCompleteEventsCounter)
	}
}

type mIEventRepositoryMockGetEvents struct {
	optional           bool
	mock               *IEventRepositoryMock
	defaultExpectation *IEventRepositoryMockGetEventsExpectation
	expectations       []*IEventRepositoryMockGetEventsExpectation

	callArgs []*IEventRepositoryMockGetEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IEventRepositoryMockGetEventsExpectation specifies expectation struct of the IEventRepository.GetEvents
type IEventRepositoryMockGetEventsExpectation struct {
	mock               *IEventRepositoryMock
	params             *IEventRepositoryMockGetEventsParams
	paramPtrs          *IEventRepositoryMockGetEventsParamPtrs
	expectationOrigins IEventRepositoryMockGetEventsExpectationOrigins
	results            *IEventRepositoryMockGetEventsResults
	returnOrigin       string
	Counter            uint64
}

// IEventRepositoryMockGetEventsParams contains parameters of the IEventRepository.GetEvents
type IEventRepositoryMockGetEventsParams struct {
	ctx context.Context
}

// IEventRepositoryMockGetEventsParamPtrs contains pointers to parameters of the IEventRepository.GetEvents
type IEventRepositoryMockGetEventsParamPtrs struct {
	ctx *context.Context
}

// IEventRepositoryMockGetEventsResults contains results of the IEventRepository.GetEvents
type IEventRepositoryMockGetEventsResults struct {
	ea1 []model.EventData
	err error
}

// IEventRepositoryMockGetEventsOrigins contains origins of expectations of the IEventRepository.GetEvents
type IEventRepositoryMockGetEventsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetEvents *mIEventRepositoryMockGetEvents) Optional() *mIEventRepositoryMockGetEvents {
	mmGetEvents.optional = true
	return mmGetEvents
}

// Expect sets up expected params for IEventRepository.GetEvents
func (mmGetEvents *mIEventRepositoryMockGetEvents) Expect(ctx context.Context) *mIEventRepositoryMockGetEvents {
	if mmGetEvents.mock.funcGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("IEventRepositoryMock.GetEvents mock is already set by Set")
	}

	if mmGetEvents.defaultExpectation == nil {
		mmGetEvents.defaultExpectation = &IEventRepositoryMockGetEventsExpectation{}
	}

	if mmGetEvents.defaultExpectation.paramPtrs != nil {
		mmGetEvents.mock.t.Fatalf("IEventRepositoryMock.GetEvents mock is already set by ExpectParams functions")
	}

	mmGetEvents.defaultExpectation.params = &IEventRepositoryMockGetEventsParams{ctx}
	mmGetEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetEvents.expectations {
		if minimock.Equal(e.params, mmGetEvents.defaultExpectation.params) {
			mmGetEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEvents.defaultExpectation.params)
		}
	}

	return mmGetEvents
}

// ExpectCtxParam1 sets up expected param ctx for IEventRepository.GetEvents
func (mmGetEvents *mIEventRepositoryMockGetEvents) ExpectCtxParam1(ctx context.Context) *mIEventRepositoryMockGetEvents {
	if mmGetEvents.mock.funcGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("IEventRepositoryMock.GetEvents mock is already set by Set")
	}

	if mmGetEvents.defaultExpectation == nil {
		mmGetEvents.defaultExpectation = &IEventRepositoryMockGetEventsExpectation{}
	}

	if mmGetEvents.defaultExpectation.params != nil {
		mmGetEvents.mock.t.Fatalf("IEventRepositoryMock.GetEvents mock is already set by Expect")
	}

	if mmGetEvents.defaultExpectation.paramPtrs == nil {
		mmGetEvents.defaultExpectation.paramPtrs = &IEventRepositoryMockGetEventsParamPtrs{}
	}
	mmGetEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetEvents
}

// Inspect accepts an inspector function that has same arguments as the IEventRepository.GetEvents
func (mmGetEvents *mIEventRepositoryMockGetEvents) Inspect(f func(ctx context.Context)) *mIEventRepositoryMockGetEvents {
	if mmGetEvents.mock.inspectFuncGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("Inspect function is already set for IEventRepositoryMock.GetEvents")
	}

	mmGetEvents.mock.inspectFuncGetEvents = f

	return mmGetEvents
}

// Return sets up results that will be returned by IEventRepository.GetEvents
func (mmGetEvents *mIEventRepositoryMockGetEvents) Return(ea1 []model.EventData, err error) *IEventRepositoryMock {
	if mmGetEvents.mock.funcGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("IEventRepositoryMock.GetEvents mock is already set by Set")
	}

	if mmGetEvents.defaultExpectation == nil {
		mmGetEvents.defaultExpectation = &IEventRepositoryMockGetEventsExpectation{mock: mmGetEvents.mock}
	}
	mmGetEvents.defaultExpectation.results = &IEventRepositoryMockGetEventsResults{ea1, err}
	mmGetEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetEvents.mock
}

// Set uses given function f to mock the IEventRepository.GetEvents method
func (mmGetEvents *mIEventRepositoryMockGetEvents) Set(f func(ctx context.Context) (ea1 []model.EventData, err error)) *IEventRepositoryMock {
	if mmGetEvents.defaultExpectation != nil {
		mmGetEvents.mock.t.Fatalf("Default expectation is already set for the IEventRepository.GetEvents method")
	}

	if len(mmGetEvents.expectations) > 0 {
		mmGetEvents.mock.t.Fatalf("Some expectations are already set for the IEventRepository.GetEvents method")
	}

	mmGetEvents.mock.funcGetEvents = f
	mmGetEvents.mock.funcGetEventsOrigin = minimock.CallerInfo(1)
	return mmGetEvents.mock
}

// When sets expectation for the IEventRepository.GetEvents which will trigger the result defined by the following
// Then helper
func (mmGetEvents *mIEventRepositoryMockGetEvents) When(ctx context.Context) *IEventRepositoryMockGetEventsExpectation {
	if mmGetEvents.mock.funcGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("IEventRepositoryMock.GetEvents mock is already set by Set")
	}

	expectation := &IEventRepositoryMockGetEventsExpectation{
		mock:               mmGetEvents.mock,
		params:             &IEventRepositoryMockGetEventsParams{ctx},
		expectationOrigins: IEventRepositoryMockGetEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetEvents.expectations = append(mmGetEvents.expectations, expectation)
	return expectation
}

// Then sets up IEventRepository.GetEvents return parameters for the expectation previously defined by the When method
func (e *IEventRepositoryMockGetEventsExpectation) Then(ea1 []model.EventData, err error) *IEventRepositoryMock {
	e.results = &IEventRepositoryMockGetEventsResults{ea1, err}
	return e.mock
}

// Times sets number of times IEventRepository.GetEvents should be invoked
func (mmGetEvents *mIEventRepositoryMockGetEvents) Times(n uint64) *mIEventRepositoryMockGetEvents {
	if n == 0 {
		mmGetEvents.mock.t.Fatalf("Times of IEventRepositoryMock.GetEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEvents.expectedInvocations, n)
	mmGetEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetEvents
}

func (mmGetEvents *mIEventRepositoryMockGetEvents) invocationsDone() bool {
	if len(mmGetEvents.expectations) == 0 && mmGetEvents.defaultExpectation == nil && mmGetEvents.mock.funcGetEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEvents.mock.afterGetEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEvents implements mm_events.IEventRepository
func (mmGetEvents *IEventRepositoryMock) GetEvents(ctx context.Context) (ea1 []model.EventData, err error) {
	mm_atomic.AddUint64(&mmGetEvents.beforeGetEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEvents.afterGetEventsCounter, 1)

	mmGetEvents.t.Helper()

	if mmGetEvents.inspectFuncGetEvents != nil {
		mmGetEvents.inspectFuncGetEvents(ctx)
	}

	mm_params := IEventRepositoryMockGetEventsParams{ctx}

	// Record call args
	mmGetEvents.GetEventsMock.mutex.Lock()
	mmGetEvents.GetEventsMock.callArgs = append(mmGetEvents.GetEventsMock.callArgs, &mm_params)
	mmGetEvents.GetEventsMock.mutex.Unlock()

	for _, e := range mmGetEvents.GetEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetEvents.GetEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEvents.GetEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEvents.GetEventsMock.defaultExpectation.params
		mm_want_ptrs := mmGetEvents.GetEventsMock.defaultExpectation.paramPtrs

		mm_got := IEventRepositoryMockGetEventsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetEvents.t.Errorf("IEventRepositoryMock.GetEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetEvents.GetEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEvents.t.Errorf("IEventRepositoryMock.GetEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetEvents.GetEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEvents.GetEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEvents.t.Fatal("No results are set for the IEventRepositoryMock.GetEvents")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetEvents.funcGetEvents != nil {
		return mmGetEvents.funcGetEvents(ctx)
	}
	mmGetEvents.t.Fatalf("Unexpected call to IEventRepositoryMock.GetEvents. %v", ctx)
	return
}

// GetEventsAfterCounter returns a count of finished IEventRepositoryMock.GetEvents invocations
func (mmGetEvents *IEventRepositoryMock) GetEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvents.afterGetEventsCounter)
}

// GetEventsBeforeCounter returns a count of IEventRepositoryMock.GetEvents invocations
func (mmGetEvents *IEventRepositoryMock) GetEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvents.beforeGetEventsCounter)
}

// Calls returns a list of arguments used in each call to IEventRepositoryMock.GetEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEvents *mIEventRepositoryMockGetEvents) Calls() []*IEventRepositoryMockGetEventsParams {
	mmGetEvents.mutex.RLock()

	argCopy := make([]*IEventRepositoryMockGetEventsParams, len(mmGetEvents.callArgs))
	copy(argCopy, mmGetEvents.callArgs)

	mmGetEvents.mutex.RUnlock()

	return argCopy
}

// MinimockGetEventsDone returns true if the count of the GetEvents invocations corresponds
// the number of defined expectations
func (m *IEventRepositoryMock) MinimockGetEventsDone() bool {
	if m.GetEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEventsMock.invocationsDone()
}

// MinimockGetEventsInspect logs each unmet expectation
func (m *IEventRepositoryMock) MinimockGetEventsInspect() {
	for _, e := range m.GetEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEventRepositoryMock.GetEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetEventsCounter := mm_atomic.LoadUint64(&m.afterGetEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventsMock.defaultExpectation != nil && afterGetEventsCounter < 1 {
		if m.GetEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IEventRepositoryMock.GetEvents at\n%s", m.GetEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IEventRepositoryMock.GetEvents at\n%s with params: %#v", m.GetEventsMock.defaultExpectation.expectationOrigins.origin, *m.GetEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEvents != nil && afterGetEventsCounter < 1 {
		m.t.Errorf("Expected call to IEventRepositoryMock.GetEvents at\n%s", m.funcGetEventsOrigin)
	}

	if !m.GetEventsMock.invocationsDone() && afterGetEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to IEventRepositoryMock.GetEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetEventsMock.expectedInvocations), m.GetEventsMock.expectedInvocationsOrigin, afterGetEventsCounter)
	}
}

type mIEventRepositoryMockSendEvent struct {
	optional           bool
	mock               *IEventRepositoryMock
	defaultExpectation *IEventRepositoryMockSendEventExpectation
	expectations       []*IEventRepositoryMockSendEventExpectation

	callArgs []*IEventRepositoryMockSendEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IEventRepositoryMockSendEventExpectation specifies expectation struct of the IEventRepository.SendEvent
type IEventRepositoryMockSendEventExpectation struct {
	mock               *IEventRepositoryMock
	params             *IEventRepositoryMockSendEventParams
	paramPtrs          *IEventRepositoryMockSendEventParamPtrs
	expectationOrigins IEventRepositoryMockSendEventExpectationOrigins
	results            *IEventRepositoryMockSendEventResults
	returnOrigin       string
	Counter            uint64
}

// IEventRepositoryMockSendEventParams contains parameters of the IEventRepository.SendEvent
type IEventRepositoryMockSendEventParams struct {
	ctx   context.Context
	event *model.SendEvent
}

// IEventRepositoryMockSendEventParamPtrs contains pointers to parameters of the IEventRepository.SendEvent
type IEventRepositoryMockSendEventParamPtrs struct {
	ctx   *context.Context
	event **model.SendEvent
}

// IEventRepositoryMockSendEventResults contains results of the IEventRepository.SendEvent
type IEventRepositoryMockSendEventResults struct {
	err error
}

// IEventRepositoryMockSendEventOrigins contains origins of expectations of the IEventRepository.SendEvent
type IEventRepositoryMockSendEventExpectationOrigins struct {
	origin      string
	originCtx   string
	originEvent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendEvent *mIEventRepositoryMockSendEvent) Optional() *mIEventRepositoryMockSendEvent {
	mmSendEvent.optional = true
	return mmSendEvent
}

// Expect sets up expected params for IEventRepository.SendEvent
func (mmSendEvent *mIEventRepositoryMockSendEvent) Expect(ctx context.Context, event *model.SendEvent) *mIEventRepositoryMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &IEventRepositoryMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.paramPtrs != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by ExpectParams functions")
	}

	mmSendEvent.defaultExpectation.params = &IEventRepositoryMockSendEventParams{ctx, event}
	mmSendEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendEvent.expectations {
		if minimock.Equal(e.params, mmSendEvent.defaultExpectation.params) {
			mmSendEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendEvent.defaultExpectation.params)
		}
	}

	return mmSendEvent
}

// ExpectCtxParam1 sets up expected param ctx for IEventRepository.SendEvent
func (mmSendEvent *mIEventRepositoryMockSendEvent) ExpectCtxParam1(ctx context.Context) *mIEventRepositoryMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &IEventRepositoryMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.params != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by Expect")
	}

	if mmSendEvent.defaultExpectation.paramPtrs == nil {
		mmSendEvent.defaultExpectation.paramPtrs = &IEventRepositoryMockSendEventParamPtrs{}
	}
	mmSendEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendEvent
}

// ExpectEventParam2 sets up expected param event for IEventRepository.SendEvent
func (mmSendEvent *mIEventRepositoryMockSendEvent) ExpectEventParam2(event *model.SendEvent) *mIEventRepositoryMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &IEventRepositoryMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.params != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by Expect")
	}

	if mmSendEvent.defaultExpectation.paramPtrs == nil {
		mmSendEvent.defaultExpectation.paramPtrs = &IEventRepositoryMockSendEventParamPtrs{}
	}
	mmSendEvent.defaultExpectation.paramPtrs.event = &event
	mmSendEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmSendEvent
}

// Inspect accepts an inspector function that has same arguments as the IEventRepository.SendEvent
func (mmSendEvent *mIEventRepositoryMockSendEvent) Inspect(f func(ctx context.Context, event *model.SendEvent)) *mIEventRepositoryMockSendEvent {
	if mmSendEvent.mock.inspectFuncSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("Inspect function is already set for IEventRepositoryMock.SendEvent")
	}

	mmSendEvent.mock.inspectFuncSendEvent = f

	return mmSendEvent
}

// Return sets up results that will be returned by IEventRepository.SendEvent
func (mmSendEvent *mIEventRepositoryMockSendEvent) Return(err error) *IEventRepositoryMock {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &IEventRepositoryMockSendEventExpectation{mock: mmSendEvent.mock}
	}
	mmSendEvent.defaultExpectation.results = &IEventRepositoryMockSendEventResults{err}
	mmSendEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendEvent.mock
}

// Set uses given function f to mock the IEventRepository.SendEvent method
func (mmSendEvent *mIEventRepositoryMockSendEvent) Set(f func(ctx context.Context, event *model.SendEvent) (err error)) *IEventRepositoryMock {
	if mmSendEvent.defaultExpectation != nil {
		mmSendEvent.mock.t.Fatalf("Default expectation is already set for the IEventRepository.SendEvent method")
	}

	if len(mmSendEvent.expectations) > 0 {
		mmSendEvent.mock.t.Fatalf("Some expectations are already set for the IEventRepository.SendEvent method")
	}

	mmSendEvent.mock.funcSendEvent = f
	mmSendEvent.mock.funcSendEventOrigin = minimock.CallerInfo(1)
	return mmSendEvent.mock
}

// When sets expectation for the IEventRepository.SendEvent which will trigger the result defined by the following
// Then helper
func (mmSendEvent *mIEventRepositoryMockSendEvent) When(ctx context.Context, event *model.SendEvent) *IEventRepositoryMockSendEventExpectation {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("IEventRepositoryMock.SendEvent mock is already set by Set")
	}

	expectation := &IEventRepositoryMockSendEventExpectation{
		mock:               mmSendEvent.mock,
		params:             &IEventRepositoryMockSendEventParams{ctx, event},
		expectationOrigins: IEventRepositoryMockSendEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendEvent.expectations = append(mmSendEvent.expectations, expectation)
	return expectation
}

// Then sets up IEventRepository.SendEvent return parameters for the expectation previously defined by the When method
func (e *IEventRepositoryMockSendEventExpectation) Then(err error) *IEventRepositoryMock {
	e.results = &IEventRepositoryMockSendEventResults{err}
	return e.mock
}

// Times sets number of times IEventRepository.SendEvent should be invoked
func (mmSendEvent *mIEventRepositoryMockSendEvent) Times(n uint64) *mIEventRepositoryMockSendEvent {
	if n == 0 {
		mmSendEvent.mock.t.Fatalf("Times of IEventRepositoryMock.SendEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendEvent.expectedInvocations, n)
	mmSendEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendEvent
}

func (mmSendEvent *mIEventRepositoryMockSendEvent) invocationsDone() bool {
	if len(mmSendEvent.expectations) == 0 && mmSendEvent.defaultExpectation == nil && mmSendEvent.mock.funcSendEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendEvent.mock.afterSendEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendEvent implements mm_events.IEventRepository
func (mmSendEvent *IEventRepositoryMock) SendEvent(ctx context.Context, event *model.SendEvent) (err error) {
	mm_atomic.AddUint64(&mmSendEvent.beforeSendEventCounter, 1)
	defer mm_atomic.AddUint64(&mmSendEvent.afterSendEventCounter, 1)

	mmSendEvent.t.Helper()

	if mmSendEvent.inspectFuncSendEvent != nil {
		mmSendEvent.inspectFuncSendEvent(ctx, event)
	}

	mm_params := IEventRepositoryMockSendEventParams{ctx, event}

	// Record call args
	mmSendEvent.SendEventMock.mutex.Lock()
	mmSendEvent.SendEventMock.callArgs = append(mmSendEvent.SendEventMock.callArgs, &mm_params)
	mmSendEvent.SendEventMock.mutex.Unlock()

	for _, e := range mmSendEvent.SendEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendEvent.SendEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendEvent.SendEventMock.defaultExpectation.Counter, 1)
		mm_want := mmSendEvent.SendEventMock.defaultExpectation.params
		mm_want_ptrs := mmSendEvent.SendEventMock.defaultExpectation.paramPtrs

		mm_got := IEventRepositoryMockSendEventParams{ctx, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendEvent.t.Errorf("IEventRepositoryMock.SendEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmSendEvent.t.Errorf("IEventRepositoryMock.SendEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendEvent.t.Errorf("IEventRepositoryMock.SendEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendEvent.SendEventMock.defaultExpectation.results
		if mm_results == nil {
			mmSendEvent.t.Fatal("No results are set for the IEventRepositoryMock.SendEvent")
		}
		return (*mm_results).err
	}
	if mmSendEvent.funcSendEvent != nil {
		return mmSendEvent.funcSendEvent(ctx, event)
	}
	mmSendEvent.t.Fatalf("Unexpected call to IEventRepositoryMock.SendEvent. %v %v", ctx, event)
	return
}

// SendEventAfterCounter returns a count of finished IEventRepositoryMock.SendEvent invocations
func (mmSendEvent *IEventRepositoryMock) SendEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendEvent.afterSendEventCounter)
}

// SendEventBeforeCounter returns a count of IEventRepositoryMock.SendEvent invocations
func (mmSendEvent *IEventRepositoryMock) SendEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendEvent.beforeSendEventCounter)
}

// Calls returns a list of arguments used in each call to IEventRepositoryMock.SendEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendEvent *mIEventRepositoryMockSendEvent) Calls() []*IEventRepositoryMockSendEventParams {
	mmSendEvent.mutex.RLock()

	argCopy := make([]*IEventRepositoryMockSendEventParams, len(mmSendEvent.callArgs))
	copy(argCopy, mmSendEvent.callArgs)

	mmSendEvent.mutex.RUnlock()

	return argCopy
}

// MinimockSendEventDone returns true if the count of the SendEvent invocations corresponds
// the number of defined expectations
func (m *IEventRepositoryMock) MinimockSendEventDone() bool {
	if m.SendEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendEventMock.invocationsDone()
}

// MinimockSendEventInspect logs each unmet expectation
func (m *IEventRepositoryMock) MinimockSendEventInspect() {
	for _, e := range m.SendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IEventRepositoryMock.SendEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendEventCounter := mm_atomic.LoadUint64(&m.afterSendEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendEventMock.defaultExpectation != nil && afterSendEventCounter < 1 {
		if m.SendEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IEventRepositoryMock.SendEvent at\n%s", m.SendEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IEventRepositoryMock.SendEvent at\n%s with params: %#v", m.SendEventMock.defaultExpectation.expectationOrigins.origin, *m.SendEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendEvent != nil && afterSendEventCounter < 1 {
		m.t.Errorf("Expected call to IEventRepositoryMock.SendEvent at\n%s", m.funcSendEventOrigin)
	}

	if !m.SendEventMock.invocationsDone() && afterSendEventCounter > 0 {
		m.t.Errorf("Expected %d calls to IEventRepositoryMock.SendEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendEventMock.expectedInvocations), m.SendEventMock.expectedInvocationsOrigin, afterSendEventCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IEventRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCompleteEventsInspect()

			m.MinimockGetEventsInspect()

			m.MinimockSendEventInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IEventRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IEventRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCompleteEventsDone() &&
		m.MinimockGetEventsDone() &&
		m.MinimockSendEventDone()
}


<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/app/app.go (0.0%)</option>
				
				<option value="file1">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/app/init_metrics.go (0.0%)</option>
				
				<option value="file2">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/app/service_provider.go (0.0%)</option>
				
				<option value="file3">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/kafka/init.go (0.0%)</option>
				
				<option value="file4">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/kafka/producer.go (0.0%)</option>
				
				<option value="file5">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/redis/go_redis/go_redis.go (0.0%)</option>
				
				<option value="file6">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter/auth.go (100.0%)</option>
				
				<option value="file7">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter/event.go (0.0%)</option>
				
				<option value="file8">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter/from_proto.go (100.0%)</option>
				
				<option value="file9">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter/to_proto.go (100.0%)</option>
				
				<option value="file10">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter/user.go (50.0%)</option>
				
				<option value="file11">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server/confirm_email.go (100.0%)</option>
				
				<option value="file12">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server/get_access_token.go (100.0%)</option>
				
				<option value="file13">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server/init.go (100.0%)</option>
				
				<option value="file14">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server/login.go (100.0%)</option>
				
				<option value="file15">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server/registration.go (100.0%)</option>
				
				<option value="file16">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server/update_password.go (100.0%)</option>
				
				<option value="file17">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server/validate.go (100.0%)</option>
				
				<option value="file18">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/interceptors/circuit_breaker.go (0.0%)</option>
				
				<option value="file19">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/interceptors/logger.go (0.0%)</option>
				
				<option value="file20">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/interceptors/metrics.go (0.0%)</option>
				
				<option value="file21">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/interceptors/rate_limiter.go (0.0%)</option>
				
				<option value="file22">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/interceptors/tracing.go (0.0%)</option>
				
				<option value="file23">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/jwt_manager/init.go (0.0%)</option>
				
				<option value="file24">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/metrics/constructor.go (0.0%)</option>
				
				<option value="file25">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/metrics/metrics.go (0.0%)</option>
				
				<option value="file26">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/rate_limiter/rate_limiter.go (0.0%)</option>
				
				<option value="file27">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/auth/confirm_email.go (0.0%)</option>
				
				<option value="file28">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/auth/get_access_token.go (0.0%)</option>
				
				<option value="file29">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/auth/init.go (0.0%)</option>
				
				<option value="file30">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/auth/login.go (0.0%)</option>
				
				<option value="file31">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/auth/registration.go (0.0%)</option>
				
				<option value="file32">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/auth/update_password.go (0.0%)</option>
				
				<option value="file33">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/events/complete_events.go (0.0%)</option>
				
				<option value="file34">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/events/get_events.go (0.0%)</option>
				
				<option value="file35">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/events/init.go (0.0%)</option>
				
				<option value="file36">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/events/send_event.go (0.0%)</option>
				
				<option value="file37">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/init.go (0.0%)</option>
				
				<option value="file38">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth/confirm_email.go (100.0%)</option>
				
				<option value="file39">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth/get_access_token.go (100.0%)</option>
				
				<option value="file40">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth/init.go (0.0%)</option>
				
				<option value="file41">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth/login.go (100.0%)</option>
				
				<option value="file42">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth/registration.go (57.6%)</option>
				
				<option value="file43">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth/update_password.go (100.0%)</option>
				
				<option value="file44">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth/validate.go (100.0%)</option>
				
				<option value="file45">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/event_sender/scheduler.go (0.0%)</option>
				
				<option value="file46">github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/init.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "flag"
        "fmt"
        "log"
        "net"
        "net/http"
        _ "net/http/pprof" // pprof package
        "os"
        "strconv"
        "sync"
        "time"

        "github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc"
        "github.com/joho/godotenv"
        "github.com/opentracing/opentracing-go"
        "github.com/sony/gobreaker"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/interceptors"
        ratelimiter "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/rate_limiter"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/closer"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
        grpcMiddleware "github.com/grpc-ecosystem/go-grpc-middleware"
)

const (
        serviceName = "auth-service"
)

var (
        // LogLevel defines the logging level, which can be set using the command-line flag "-l".
        LogLevel = flag.String("l", "info", "log level")
        envPath  = ".env" // EnvPath - contains path to .env file
)

// App struct encapsulates the dependencies and the gRPC server instance.
type App struct {
        serviceProvider *serviceProvider
        grpcServer      *grpc.Server
        prometheus      *http.Server
}

// New creates a new instance of App and initializes its dependencies.
func New(ctx context.Context) (*App, error) <span class="cov0" title="0">{
        const mark = "App.app.New"

        app := &amp;App{}
        err := app.InitDeps(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to init deps", mark, zap.Error(err))
        }</span>
        <span class="cov0" title="0">return app, nil</span>
}

// Run starts the gRPC server and ensures proper resource cleanup.
func (a *App) Run(ctx context.Context) error <span class="cov0" title="0">{
        const mark = "App.app.Run"

        defer func() </span><span class="cov0" title="0">{
                closer.CloseAll()
                closer.Wait()
        }</span>()

        // outbox scheduler
        <span class="cov0" title="0">a.serviceProvider.Service(ctx).Event.Start(ctx, GetSchedulerPeriod())

        wg := &amp;sync.WaitGroup{}
        wg.Add(3)

        go func() </span><span class="cov0" title="0">{
                defer wg.Wait()
                logger.Info("starting pprof server on :6060", mark)
                if err := http.ListenAndServe(":6060", nil); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to start pprof server: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                err := a.runPrometheus()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to run metrics", mark, zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                err := a.RunGRPCServer()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to run grpc server", mark, zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">wg.Wait()
        return nil</span>
}

// InitDeps initializes all dependencies required by the App.
func (a *App) InitDeps(ctx context.Context) error <span class="cov0" title="0">{
        const mark = "App.app.InitDeps"

        inits := []func(context.Context) error{
                a.InitConfig,
                a.initServiceProvider,
                a.initGrpcServer,
                a.initPrometheus,
                a.initMetrics,
        }
        for _, fun := range inits </span><span class="cov0" title="0">{
                if err := fun(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to init deps", mark, zap.Error(err))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// InitConfig loads environment variables from the specified path.
func (a *App) InitConfig(_ context.Context) error <span class="cov0" title="0">{
        const mark = "App.app.InitConfig"

        err := godotenv.Load(envPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading .env file", mark, zap.String("path", envPath))
                return fmt.Errorf("error loading .env file: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// initServiceProvider initializes the service provider.
func (a *App) initServiceProvider(_ context.Context) error <span class="cov0" title="0">{
        a.serviceProvider = newServiceProvider()
        return nil
}</span>

// initGrpcServer initializes the gRPC server and configures logging.
func (a *App) initGrpcServer(ctx context.Context) error <span class="cov0" title="0">{
        flag.Parse()
        logger.Init(logger.GetCore(logger.GetAtomicLevel(LogLevel)))
        a.InitTracing(serviceName)

        rateLimiter := ratelimiter.NewTokenBucketLimiter(ctx, 1000, time.Second)

        a.grpcServer = grpc.NewServer(
                grpc.UnaryInterceptor(
                        grpcMiddleware.ChainUnaryServer(
                                otgrpc.OpenTracingServerInterceptor(opentracing.GlobalTracer()),
                                interceptors.NewRateLimitInterceptor(rateLimiter).Unary,
                                interceptors.NewCircuitBreaker(GetCircuitBreakerConfig()).Unary,
                                interceptors.LogInterceptor,
                                interceptors.MetricsInterceptor,
                        ),
                ))
        reflection.Register(a.grpcServer)
        authService.RegisterAuthV1Server(a.grpcServer, a.serviceProvider.GrpcServer(ctx))

        return nil
}</span>

// RunGRPCServer starts the gRPC server and listens on the configured address.
func (a *App) RunGRPCServer() error <span class="cov0" title="0">{
        const mark = "App.app.RunGRPCServer"

        logger.Info("starting grpc server on "+a.serviceProvider.GRPCConfig().GetAddress(), mark)
        list, err := net.Listen("tcp", a.serviceProvider.GRPCConfig().GetAddress())
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to listen grpc", mark, zap.Error(err))
        }</span>

        <span class="cov0" title="0">err = a.grpcServer.Serve(list)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to serve grpc", mark, zap.Error(err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSchedulerPeriod returns the period for the outbox scheduler in milliseconds.
func GetSchedulerPeriod() time.Duration <span class="cov0" title="0">{
        const mark = "App.app.GetSchedulerPeriod"

        period, err := strconv.Atoi(os.Getenv("OUTBOX_SCHEDULER_PERIOD"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get outbox scheduler period", mark, zap.Error(err))
                log.Fatalf("failed to get outbox scheduler period: %v", err)
        }</span>
        <span class="cov0" title="0">return time.Duration(period) * time.Millisecond</span>
}

// GetCircuitBreakerConfig initializes and returns a configured Circuit Breaker for the auth-service.
// The Circuit Breaker trips when the failure ratio exceeds 60%, with a timeout of 5 seconds for resetting.
func GetCircuitBreakerConfig() *gobreaker.CircuitBreaker <span class="cov0" title="0">{
        const mark = "App.app.GetCircuitBreakerConfig"

        cb := gobreaker.NewCircuitBreaker(gobreaker.Settings{
                Name:        serviceName,
                MaxRequests: 3,
                Timeout:     5 * time.Second,
                ReadyToTrip: func(counts gobreaker.Counts) bool </span><span class="cov0" title="0">{
                        failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
                        return failureRatio &gt;= 0.6
                }</span>,
                OnStateChange: func(name string, from, to gobreaker.State) <span class="cov0" title="0">{
                        logger.Warn("circuit breaker state changed", mark, zap.String("name", name), zap.String("from", from.String()), zap.String("to", to.String()))
                }</span>,
        })

        <span class="cov0" title="0">return cb</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "context"
        "net/http"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
        "github.com/uber/jaeger-client-go/config"
        "go.uber.org/zap"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/metrics"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

const (
        metricsRoute = "/metrics"
)

func (a *App) initPrometheus(_ context.Context) error <span class="cov0" title="0">{
        mux := http.NewServeMux()
        mux.Handle(metricsRoute, promhttp.Handler())

        a.prometheus = &amp;http.Server{
                Addr:    a.serviceProvider.PrometheusConfig().Address(),
                Handler: mux,
        }
        return nil
}</span>

func (a *App) runPrometheus() error <span class="cov0" title="0">{

        const mark = "App.app.runPrometheus"

        logger.Info("starting prometheus server on "+a.serviceProvider.PrometheusConfig().Address(), mark)
        return a.prometheus.ListenAndServe()
}</span>

func (a *App) initMetrics(ctx context.Context) error <span class="cov0" title="0">{

        const mark = "App.app.initMetrics"

        err := metrics.Init(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to init metrics", mark, zap.Error(err))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// InitTracing initializes the global tracer for the application using Jaeger as the tracing backend.
// It accepts the service name as a parameter, which will be used to identify the service in tracing data.
// The tracer is configured with a constant sampler that always samples all requests.
// If the tracer initialization fails, the function logs the error and terminates the application.
func (a *App) InitTracing(serviceName string) <span class="cov0" title="0">{

        const mark = "Tracing.Init"

        cfg := config.Configuration{
                Sampler: &amp;config.SamplerConfig{
                        Type:  "const",
                        Param: 1,
                },
        }

        _, err := cfg.InitGlobalTracer(serviceName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to init tracer", mark, zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/metrics"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/kafka"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/redis"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/redis/go_redis"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/grpc_server"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/jwt_manager"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/closer"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db/pg"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db/transaction"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "go.uber.org/zap"
)

// serviceProvider struct holds configurations and instances needed to set up and manage services.
type serviceProvider struct {
        // configs
        pgConfig         db.PGConfig
        grpcConfig       GRPCConfig
        redisConfig      redis.IRedisConfig
        kafkaConfig      kafka.IKafkaConfig
        prometheusConfig metrics.PrometheusConfig

        // clients
        dbClient      db.Client
        txManager     db.TxManager
        authHelper    jwt_manager.AuthHelper
        redisClient   redis.IRedis
        kafkaProducer kafka.IProducer

        // layers
        grpcServer *grpc_server.GrpcServer
        service    *service.Service
        repository *repository.Repository
}

// newServiceProvider creates a new instance of serviceProvider.
func newServiceProvider() *serviceProvider <span class="cov0" title="0">{
        return &amp;serviceProvider{}
}</span>

// PGConfig initializes and returns the PostgresSQL configuration if not already set.
func (s *serviceProvider) PGConfig() db.PGConfig <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.PGConfig"

        if s.pgConfig == nil </span><span class="cov0" title="0">{
                cfg, err := db.NewPgConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to get pg config", mark, zap.Error(err))
                }</span>
                <span class="cov0" title="0">s.pgConfig = cfg</span>
        }
        <span class="cov0" title="0">return s.pgConfig</span>
}

// GRPCConfig initializes and returns the gRPC configuration if not already set.
func (s *serviceProvider) GRPCConfig() GRPCConfig <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.GRPCConfig"

        if s.grpcConfig == nil </span><span class="cov0" title="0">{
                cfg, err := NewGrpcConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to get grpc config", mark, zap.Error(err))
                }</span>
                <span class="cov0" title="0">s.grpcConfig = cfg</span>
        }
        <span class="cov0" title="0">return s.grpcConfig</span>
}

// RedisConfig retrieves the Redis configuration, initializing it if necessary.
func (s *serviceProvider) RedisConfig() redis.IRedisConfig <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.RedisConfig"

        if s.redisConfig == nil </span><span class="cov0" title="0">{
                cfg, err := redis.NewRedisConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to get redis config", mark, zap.Error(err))
                }</span>
                <span class="cov0" title="0">s.redisConfig = cfg</span>
        }
        <span class="cov0" title="0">return s.redisConfig</span>
}

func (s *serviceProvider) KafkaConfig() kafka.IKafkaConfig <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.KafkaConfig"

        if s.kafkaConfig == nil </span><span class="cov0" title="0">{
                cfg, err := kafka.NewKafkaConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to get kafka config", mark, zap.Error(err))
                }</span>
                <span class="cov0" title="0">s.kafkaConfig = cfg</span>
        }
        <span class="cov0" title="0">return s.kafkaConfig</span>

}

func (s *serviceProvider) PrometheusConfig() metrics.PrometheusConfig <span class="cov0" title="0">{

        const mark = "App.ServiceProvider.PrometheusConfig"

        if s.prometheusConfig == nil </span><span class="cov0" title="0">{
                cfg, err := metrics.NewPrometheusConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to get metrics config", mark, zap.Error(err))
                }</span>
                <span class="cov0" title="0">s.prometheusConfig = cfg</span>
        }

        <span class="cov0" title="0">return s.prometheusConfig</span>
}

// DBClient initializes and returns the database client if not already created.
// It also pings the database to ensure the connection is valid.
func (s *serviceProvider) DBClient(ctx context.Context) db.Client <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.DBClient"

        if s.dbClient == nil </span><span class="cov0" title="0">{
                cfg := s.PGConfig()
                dbc, err := pg.New(ctx, cfg.GetDSN())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to get db client", mark, zap.Error(err))
                }</span>

                <span class="cov0" title="0">err = dbc.DB().Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to ping db", mark, zap.Error(err))
                }</span>

                <span class="cov0" title="0">closer.Add(dbc.Close) // Ensures the database client is closed on shutdown
                s.dbClient = dbc</span>
        }
        <span class="cov0" title="0">return s.dbClient</span>
}

func (s *serviceProvider) TxManager(ctx context.Context) db.TxManager <span class="cov0" title="0">{
        if s.txManager == nil </span><span class="cov0" title="0">{
                s.txManager = transaction.NewTransactionManager(s.DBClient(ctx).DB())
        }</span>
        <span class="cov0" title="0">return s.txManager</span>
}

// RedisClient initializes and returns the Redis client if not already created.
// It also pings Redis to ensure the connection is valid.
func (s *serviceProvider) RedisClient(ctx context.Context) redis.IRedis <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.RedisClient"

        if s.redisClient == nil </span><span class="cov0" title="0">{
                redisClient := go_redis.NewGoRedisClient(s.RedisConfig())
                closer.Add(redisClient.Client.Close)

                err := redisClient.Client.Ping(ctx).Err()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to connect to redis", mark, zap.Error(err))
                }</span>

                <span class="cov0" title="0">s.redisClient = redisClient</span>
        }
        <span class="cov0" title="0">return s.redisClient</span>
}

// KafkaProducer returns an instance of the Kafka producer.
// If the Kafka producer is not created yet, it creates a new one using the Kafka configuration addresses.
// In case of an error while creating the producer, the function logs a fatal error and stops execution.
// It also adds the producer's Close method to "closer" to ensure proper cleanup when done.
func (s *serviceProvider) KafkaProducer() kafka.IProducer <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.KafkaProducer"

        if s.kafkaProducer == nil </span><span class="cov0" title="0">{
                producer, err := kafka.NewProducer(s.KafkaConfig().Address())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to create kafka producer", mark, zap.Error(err))
                }</span>
                <span class="cov0" title="0">closer.Add(producer.Close)
                s.kafkaProducer = producer</span>
        }
        <span class="cov0" title="0">return s.kafkaProducer</span>
}

// AuthHelper initializes and returns the authentication helper if not already created.
func (s *serviceProvider) AuthHelper() jwt_manager.AuthHelper <span class="cov0" title="0">{
        const mark = "App.ServiceProvider.AuthHelper"

        if s.authHelper == nil </span><span class="cov0" title="0">{
                cfg, err := jwt_manager.NewAuthConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to get auth config", mark, zap.Error(err))
                }</span>

                <span class="cov0" title="0">s.authHelper = jwt_manager.New(cfg.GetSecretKey(), cfg.GetRefreshTokenDuration(), cfg.GetAccessTokenDuration())</span>
        }
        <span class="cov0" title="0">return s.authHelper</span>
}

// Repository initializes and returns the repository layer for database operations.
func (s *serviceProvider) Repository(ctx context.Context) *repository.Repository <span class="cov0" title="0">{
        if s.repository == nil </span><span class="cov0" title="0">{
                s.repository = repository.New(s.DBClient(ctx), s.RedisClient(ctx))
        }</span>
        <span class="cov0" title="0">return s.repository</span>
}

// Service initializes and returns the service layer for core business logic.
func (s *serviceProvider) Service(ctx context.Context) *service.Service <span class="cov0" title="0">{
        if s.service == nil </span><span class="cov0" title="0">{
                s.service = service.New(s.Repository(ctx),
                        s.AuthHelper(),
                        s.TxManager(ctx),
                        s.KafkaProducer(),
                        s.DBClient(ctx))
        }</span>
        <span class="cov0" title="0">return s.service</span>
}

// GrpcServer initializes and returns the controller layer to handle business logic requests.
func (s *serviceProvider) GrpcServer(ctx context.Context) *grpc_server.GrpcServer <span class="cov0" title="0">{
        if s.grpcServer == nil </span><span class="cov0" title="0">{
                s.grpcServer = grpc_server.New(s.Service(ctx))
        }</span>
        <span class="cov0" title="0">return s.grpcServer</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package kafka

import (
        "fmt"
        "strings"

        "github.com/confluentinc/confluent-kafka-go/v2/kafka"
)

// IProducer defines an interface for a Kafka producer with methods for sending messages and closing.
type IProducer interface {
        // Produce sends a message to a specified Kafka topic.
        Produce(message, topic, key string) error

        // Close gracefully shuts down the producer and flushes pending messages.
        Close() error
}

// Producer wraps a Kafka producer to handle message production to Kafka topics.
type Producer struct {
        // producer is the underlying Kafka producer instance.
        producer *kafka.Producer
}

// NewProducer creates and initializes a new Producer with the given Kafka broker addresses.
func NewProducer(addresses []string) (*Producer, error) <span class="cov0" title="0">{
        config := &amp;kafka.ConfigMap{
                "bootstrap.servers": strings.Join(addresses, ","),
        }
        producer, err := kafka.NewProducer(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create producer: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;Producer{producer: producer}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package kafka

import (
        "errors"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
        "go.uber.org/zap"

        "github.com/confluentinc/confluent-kafka-go/v2/kafka"
)

// unknownType represents an error for unrecognized event types.
var errUnknownType = errors.New("unknown event type")

const (
        // flushTimeout defines the timeout in milliseconds for flushing the Kafka producer.
        flushTimeout = 5000
)

// Produce sends a message with a key and timestamp to the specified Kafka topic.
func (p *Producer) Produce(message, topic, key string) error <span class="cov0" title="0">{
        const mark = "Cients.Kafka.Producer"

        kafkaMessage := &amp;kafka.Message{
                TopicPartition: kafka.TopicPartition{Topic: &amp;topic, Partition: kafka.PartitionAny},
                Value:          []byte(message),
                Key:            []byte(key),
                Timestamp:      time.Now(),
        }
        kafkaChan := make(chan kafka.Event)

        if err := p.producer.Produce(kafkaMessage, kafkaChan); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to produce event", mark, zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">event := &lt;-kafkaChan
        switch event.(type) </span>{
        case *kafka.Message:<span class="cov0" title="0">
                m := event.(*kafka.Message)
                if m.TopicPartition.Error != nil </span><span class="cov0" title="0">{
                        return m.TopicPartition.Error
                }</span>
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return errUnknownType</span>
        }
}

// Close gracefully shuts down the Kafka producer after flushing pending messages.
func (p *Producer) Close() error <span class="cov0" title="0">{
        p.producer.Flush(flushTimeout)
        p.producer.Close()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package go_redis

import (
        "context"
        "fmt"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/redis"
        "github.com/goccy/go-json"
        goRedis "github.com/redis/go-redis/v9"
        "go.uber.org/zap"
)

// Ensure GoRedisClient implements the RedisClient interface
var _ redis.IRedis = (*GoRedisClient)(nil)

// GoRedisClient is a wrapper around the go-redis client, providing methods
// for interacting with a Redis data store.
type GoRedisClient struct {
        Client *goRedis.Client // Underlying go-redis client instance
}

// NewGoRedisClient initializes a new GoRedisClient with the provided Redis configuration.
// It creates a new Redis client using the configuration's address.
func NewGoRedisClient(config redis.IRedisConfig) *GoRedisClient <span class="cov0" title="0">{
        redisClient := &amp;GoRedisClient{
                Client: goRedis.NewClient(&amp;goRedis.Options{
                        Addr:     config.Address(),
                        Password: "", // Password is set to an empty string for no authentication
                        DB:       0,  // Using the default database
                }),
        }

        return redisClient
}</span>

// Set stores a string value in Redis under the specified key with a given duration.
// The duration determines how long the value will be stored before expiring.
func (g *GoRedisClient) Set(ctx context.Context, key string, value string, duration time.Duration) error <span class="cov0" title="0">{
        return g.Client.Set(ctx, key, value, duration).Err()
}</span>

// Get retrieves the string value associated with the specified key from Redis.
// If the key does not exist or an error occurs, it returns an error.
func (g *GoRedisClient) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return g.Client.Get(ctx, key).Result()
}</span>

// SetObject serializes a given object into JSON format and stores it in Redis under the specified key
// with a given duration. If marshaling fails, an error is returned.
func (g *GoRedisClient) SetObject(ctx context.Context, key string, value interface{}, duration time.Duration) error <span class="cov0" title="0">{
        noteBytes, err := json.Marshal(value) // Serialize the object to JSON
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal note: %v", err) // Return an error if marshaling fails
        }</span>
        <span class="cov0" title="0">g.Client.Set(ctx, key, string(noteBytes), duration) // Store the JSON string in Redis with expiration
        return nil</span>
}

// GetObject retrieves the JSON string associated with the specified key from Redis,
// unmarshals it into the provided value parameter. If retrieval or unmarshaling fails,
// an error is returned.
func (g *GoRedisClient) GetObject(ctx context.Context, key string, value any) error <span class="cov0" title="0">{
        const mark = "Clients.Redis.GoRedis.GetObject"

        val, err := g.Client.Get(ctx, key).Result() // Retrieve the value from Redis
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get note from redis: %v", err) // Return an error if retrieval fails
        }</span>
        <span class="cov0" title="0">logger.Debug("get note from redis", mark, zap.String("val", val)) // Log the retrieved value for debugging

        if err = json.Unmarshal([]byte(val), &amp;value); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal note: %v", err) // Return an error if unmarshaling fails
        }</span>
        <span class="cov0" title="0">logger.Debug("unmarshal note", mark, zap.Any("value", value)) // Log the unmarshaled value for debugging
        return nil</span>
}

// Delete removes the specified key and its associated value from Redis.
// It returns an error if the deletion fails.
func (g *GoRedisClient) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        return g.Client.Del(ctx, key).Err()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package converter

import "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"

// ToModelAuthResponse converts access and refresh tokens along with user ID
// into an AuthResponse model.
func ToModelAuthResponse(accessToken, refreshToken string, UserID int) *model.AuthResponse <span class="cov8" title="10">{
        return &amp;model.AuthResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                UserID:       int64(UserID),
        }
}</span>

// ToModelAccessTokenInfo converts user ID and user information into an
// AccessTokenInfo model.
func ToModelAccessTokenInfo(userID int, userInfo *model.UserInfo) *model.AccessTokenInfo <span class="cov10" title="15">{
        return &amp;model.AccessTokenInfo{
                ID:   userID,
                Role: userInfo.Role,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package converter

import (
        "strconv"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
)

// ToModelPayload converts topic, user ID, and user information into a Payload model.
func ToModelPayload(topic string, UserID int, userInfo *model.UserInfo) *model.Payload <span class="cov0" title="0">{
        return &amp;model.Payload{
                Topic:   topic,
                Key:     strconv.Itoa(UserID),
                Message: userInfo.Email,
        }
}</span>

// ToModelSendEvent converts an event name and payload into a SendEvent model.
func ToModelSendEvent(event string, payload []byte) *model.SendEvent <span class="cov0" title="0">{
        return &amp;model.SendEvent{
                Event:   event,
                Payload: string(payload),
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package converter

import (
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
)

// ToInfoFromProto converts a RegistrationRequest from the authService to a UserInfo model.
// This is used to transform incoming registration data into a format suitable for further processing.
func ToInfoFromProto(info *authService.RegistrationRequest) *model.UserInfo <span class="cov9" title="15">{
        return &amp;model.UserInfo{
                Email:    info.GetEmail(),
                Password: info.GetPassword(),
                Name:     info.GetName(),
                Surname:  info.GetSurname(),
                Role:     info.GetRole(),
        }
}</span>

// ToLoginInfoFromProto converts a LoginRequest from the authService to a LoginInfo model.
// This function maps login details from the incoming request to the model structure used in the application.
func ToLoginInfoFromProto(info *authService.LoginRequest) *model.LoginInfo <span class="cov7" title="10">{
        return &amp;model.LoginInfo{
                Email:    info.GetEmail(),
                Password: info.GetPassword(),
        }
}</span>

// ToUpdatePassFromProto converts an UpdatePasswordRequest from the authService to an UpdatePassInfo model.
// It is used to extract and prepare email and new password information for updating user credentials.
func ToUpdatePassFromProto(info *authService.UpdatePasswordRequest) *model.UpdatePassInfo <span class="cov10" title="20">{
        return &amp;model.UpdatePassInfo{
                Email:       info.GetEmail(),
                NewPassword: info.GetNewPassword(),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package converter

import (
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
)

// ToProtoFromLoginResponse converts the AuthResponse model into a gRPC-compatible LoginResponse.
// This is useful for sending authentication details back to the client after a successful login.
func ToProtoFromLoginResponse(resp *model.AuthResponse) *authService.LoginResponse <span class="cov7" title="5">{
        return &amp;authService.LoginResponse{
                AccessToken:  resp.AccessToken,
                RefreshToken: resp.RefreshToken,
                UserId:       resp.UserID,
        }
}</span>

// ToProtoFromNewPairTokens transforms the NewPairTokens model into a gRPC GetAccessTokenResponse.
// This is used to provide the client with a new pair of access and refresh tokens.
func ToProtoFromNewPairTokens(resp *model.NewPairTokens) *authService.GetAccessTokenResponse <span class="cov7" title="5">{
        return &amp;authService.GetAccessTokenResponse{
                AccessToken:  resp.AccessToken,
                RefreshToken: resp.RefreshToken,
        }
}</span>

// ToProtoFromRegResponse converts the AuthResponse model into a RegistrationResponse for gRPC.
// This allows the client to receive authentication tokens after successful registration.
func ToProtoFromRegResponse(resp *model.AuthResponse) *authService.RegistrationResponse <span class="cov10" title="10">{
        return &amp;authService.RegistrationResponse{
                AccessToken:  resp.AccessToken,
                RefreshToken: resp.RefreshToken,
                UserId:       resp.UserID,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package converter

import (
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
)

// FromUserInfoToDbModel converts UserInfo and hashed password to InfoToDb model.
func FromUserInfoToDbModel(info *model.UserInfo, hashedPassword string) *model.InfoToDb <span class="cov0" title="0">{
        return &amp;model.InfoToDb{
                Email:        info.Email,
                HashPassword: hashedPassword,
                Role:         info.Role,
        }
}</span>

// FromUpdatePassInfoToDbPassInfo converts UpdatePassInfo and hashed password to UpdatePassDb model.
func FromUpdatePassInfoToDbPassInfo(info *model.UpdatePassInfo, hashedPassword string) *model.UpdatePassDb <span class="cov10" title="10">{
        return &amp;model.UpdatePassDb{
                Email:        info.Email,
                HashPassword: hashedPassword,
                UpdatedAt:    time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package grpc_server

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/emptypb"
)

// ConfirmEmail is a gRPC handler that processes email confirmation requests.
// It calls the service layer to mark the email as verified and returns an error if the operation fails.
func (c *GrpcServer) ConfirmEmail(ctx context.Context, req *authService.ConfirmEmailRequest) (*emptypb.Empty, error) <span class="cov10" title="10">{
        const mark = "GrpcServer.ConfirmEmail"

        err := c.svc.Auth.ConfirmEmail(ctx, req.GetEmail())
        if err != nil </span><span class="cov7" title="5">{
                logger.Error("failed to confirm email", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to confirm email: %v", err)
        }</span>

        <span class="cov7" title="5">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package grpc_server

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
        "go.uber.org/zap"
)

// GetAccessToken handles the request for generating an access token.
func (c *GrpcServer) GetAccessToken(ctx context.Context,
        req *authService.GetAccessTokenRequest) (*authService.GetAccessTokenResponse, error) <span class="cov10" title="10">{
        const mark = "GrpcServer.GetAccessToken"

        logger.Debug("getting refresh token", mark, zap.String("REFRESH_TOKEN", req.GetRefreshToken()))

        res, err := c.svc.Auth.GetAccessToken(ctx, req.GetRefreshToken())
        if err != nil </span><span class="cov7" title="5">{
                logger.Error("failed to get access token", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov7" title="5">logger.Debug("new pair tokens: ", mark, zap.Any("tokens", res))
        return converter.ToProtoFromNewPairTokens(res), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package grpc_server

import (
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
)

// GrpcServer handles gRPC requests for the authentication service.
// It embeds UnimplementedAuthV1Server to provide default implementations
// for the gRPC server methods, allowing customization where needed.
type GrpcServer struct {
        authService.UnimplementedAuthV1Server
        svc *service.Service
}

// New creates a new instance of Controller with the provided service.
// The service is used to manage authentication-related operations.
func New(svc *service.Service) *GrpcServer <span class="cov10" title="85">{
        return &amp;GrpcServer{
                svc: svc,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package grpc_server

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/validator"
        "go.uber.org/zap"
)

// Login processes user login requests and returns a login response.
func (c *GrpcServer) Login(ctx context.Context,
        req *authService.LoginRequest) (*authService.LoginResponse, error) <span class="cov10" title="25">{

        const mark = "GrpcServer.Login"

        logger.Debug("get user data in controller", mark, zap.Any("req", req))

        err := Validate(ctx, req)
        if err != nil </span><span class="cov8" title="15">{
                logger.Error("failed to validate", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov7" title="10">result, err := c.svc.Auth.Login(ctx, converter.ToLoginInfoFromProto(req))
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to login", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov5" title="5">logger.Debug("new pair tokens: ", mark, zap.Any("tokens", result))

        return converter.ToProtoFromLoginResponse(result), nil</span>
}

// Validate checks the validity of the provided login request.
func Validate(ctx context.Context, req *authService.LoginRequest) error <span class="cov10" title="25">{
        err := validator.Validate(ctx,
                validator.ValidateEmail(req.GetEmail()),
                validator.ValidatePassword(req.GetPassword()))
        if err != nil </span><span class="cov8" title="15">{
                return err
        }</span>
        <span class="cov7" title="10">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package grpc_server

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/validator"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
        "go.uber.org/zap"
)

// Registration handles user registration requests and returns a registration response.
func (c *GrpcServer) Registration(ctx context.Context,
        req *authService.RegistrationRequest) (*authService.RegistrationResponse, error) <span class="cov10" title="15">{

        const mark = "GrpcServer.Registration"

        logger.Debug("registration", mark, zap.Any("req", req))

        err := ValidateUserData(ctx, req)
        if err != nil </span><span class="cov6" title="5">{
                logger.Info("failed to validate", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="10">res, err := c.svc.Auth.Registration(ctx, converter.ToInfoFromProto(req))
        if err != nil </span><span class="cov6" title="5">{
                logger.Error(err.Error(), mark, zap.Any("req", req))
                return nil, fmt.Errorf("failed to registration: %v", err)
        }</span>

        <span class="cov6" title="5">logger.Debug("new pair tokens: ", mark, zap.Any("tokens", res))

        return converter.ToProtoFromRegResponse(res), nil</span>
}

// ValidateUserData validates the user registration request data.
func ValidateUserData(ctx context.Context, req *authService.RegistrationRequest) error <span class="cov10" title="15">{
        return validator.Validate(ctx,
                validator.ValidateName(req.GetName()),
                validator.ValidateRole(req.GetRole()),
                validator.ValidateEmail(req.GetEmail()),
                validator.ValidatePassword(req.GetPassword()),
                validator.ValidateSurname(req.GetSurname()),
        )
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package grpc_server

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/validator"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter"
        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/emptypb"
)

// UpdatePassword processes requests to update a user's password and returns an empty response.
func (c *GrpcServer) UpdatePassword(ctx context.Context,
        req *authService.UpdatePasswordRequest) (*emptypb.Empty, error) <span class="cov10" title="15">{

        const mark = "GrpcServer.UpdatePassword"

        logger.Debug("update password", mark, zap.Any("req", req))

        err := validator.Validate(
                ctx,
                validator.ValidateEmail(req.GetEmail()),
                validator.ValidatePassword(req.GetNewPassword()))
        if err != nil </span><span class="cov6" title="5">{
                logger.Error("failed to validate", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="10">err = c.svc.Auth.UpdatePassword(ctx, converter.ToUpdatePassFromProto(req))
        if err != nil </span><span class="cov6" title="5">{
                logger.Error("failed to update password", mark, zap.Error(err))
                return nil, err
        }</span>
        <span class="cov6" title="5">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package grpc_server

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        authService "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/auth_v1"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/emptypb"
)

// ValidateToken checks the validity of the provided access token and returns an empty response.
func (c *GrpcServer) ValidateToken(ctx context.Context,
        req *authService.ValidateTokenRequest) (*emptypb.Empty, error) <span class="cov10" title="10">{

        const mark = "GrpcServer.ValidateToken"

        _, err := c.svc.Auth.ValidateToken(ctx, req.GetAccessToken())
        if err != nil </span><span class="cov7" title="5">{
                logger.Error("failed to validate token", mark, zap.Any("req", req))
                return nil, err
        }</span>
        <span class="cov7" title="5">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package interceptors

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
        "go.uber.org/zap"

        "github.com/sony/gobreaker"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// CircuitBreaker provides a gRPC interceptor with a circuit breaker mechanism.
type CircuitBreaker struct {
        cb *gobreaker.CircuitBreaker // Gobreaker circuit breaker instance.
}

// NewCircuitBreaker initializes a new CircuitBreaker with the provided gobreaker instance.
func NewCircuitBreaker(cb *gobreaker.CircuitBreaker) *CircuitBreaker <span class="cov0" title="0">{
        return &amp;CircuitBreaker{cb: cb}
}</span>

// Unary is a gRPC unary interceptor that wraps requests with a circuit breaker.
// If the circuit breaker is in the open state, it returns a service unavailable error.
func (c *CircuitBreaker) Unary(ctx context.Context,
        req interface{},
        _ *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{
        const mark = "Interceptors.CircuitBreakerInterceptor"

        res, err := c.cb.Execute(func() (interface{}, error) </span><span class="cov0" title="0">{
                return handler(ctx, req)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if err == gobreaker.ErrOpenState </span><span class="cov0" title="0">{
                        logger.Error("service unavailable", mark, zap.Error(err))
                        return nil, status.Error(codes.Unavailable, "service unavailable")
                }</span>
                <span class="cov0" title="0">logger.Error("failed to execute", mark, zap.Error(err))
                return nil, err</span>
        }

        <span class="cov0" title="0">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package interceptors

import (
        "context"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "go.uber.org/zap"
        "google.golang.org/grpc"
)

// LogInterceptor is a gRPC interceptor that logs the details of incoming requests and their processing time.
func LogInterceptor(ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler) (resp interface{}, err error) <span class="cov0" title="0">{

        const mark = "Interceptors.LogInterceptor"

        start := time.Now()

        resp, err = handler(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error(), mark, zap.String("method", info.FullMethod), zap.Any("req", req))
        }</span>
        <span class="cov0" title="0">logger.Info("request", mark, zap.String("method", info.FullMethod), zap.Any("req", req), zap.Any("resp", resp), zap.Duration("duration", time.Since(start)))
        return resp, err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package interceptors

import (
        "context"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/metrics"
        "google.golang.org/grpc"
)

// MetricsInterceptor -    Prometheus
func MetricsInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{
        metrics.IncRequestCounter()

        timeStart := time.Now()

        res, err := handler(ctx, req)

        diffTime := time.Since(timeStart)

        if err != nil </span><span class="cov0" title="0">{
                metrics.IncResponseCounter("error", info.FullMethod)
                metrics.ObserveResponseTime("error", diffTime.Seconds())
        }</span> else<span class="cov0" title="0"> {
                metrics.IncResponseCounter("success", info.FullMethod)
                metrics.ObserveResponseTime("success", diffTime.Seconds())
        }</span>

        <span class="cov0" title="0">return res, err</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package interceptors

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        ratelimiter "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/rate_limiter"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// RateLimiter provides a gRPC interceptor to enforce rate limiting on requests.
type RateLimiter struct {
        rateLimiter *ratelimiter.TokenBucketLimiter // Token bucket rate limiter instance.
}

// NewRateLimitInterceptor creates a new RateLimiter interceptor with the provided rate limiter.
func NewRateLimitInterceptor(rateLimiter *ratelimiter.TokenBucketLimiter) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{rateLimiter: rateLimiter}
}</span>

// Unary is a gRPC unary interceptor that applies rate limiting to incoming requests.
// Returns a rate limit exceeded error if the request exceeds the allowed limit.
func (r *RateLimiter) Unary(ctx context.Context,
        req interface{},
        _ *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{

        const mark = "Interceptors.RateLimitInterceptor"
        if !r.rateLimiter.Allow() </span><span class="cov0" title="0">{
                logger.Warn("rate limit exceeded", mark)
                return nil, status.Error(codes.ResourceExhausted, "rate limit exceeded")
        }</span>

        <span class="cov0" title="0">return handler(ctx, req)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package interceptors

import (
        "context"

        "github.com/opentracing/opentracing-go"
        "github.com/opentracing/opentracing-go/ext"
        "github.com/uber/jaeger-client-go"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
)

const traceIDKey = "x-trace-id"

// ServerTracing is a gRPC server interceptor that integrates with OpenTracing for distributed tracing.
// It starts a new span for each incoming gRPC request, attaches the trace ID to the metadata, and
// sends it as part of the response headers.
// The method also captures errors and response information, annotating the span accordingly.
func ServerTracing(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{

        span, ctx := opentracing.StartSpanFromContext(ctx, info.FullMethod)
        defer span.Finish()

        spanContext, ok := span.Context().(jaeger.SpanContext)
        if ok </span><span class="cov0" title="0">{
                ctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(traceIDKey, spanContext.TraceID().String()))
                header := metadata.New(map[string]string{traceIDKey: spanContext.TraceID().String()})
                err := grpc.SendHeader(ctx, header)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">res, err := handler(ctx, req)

        if err != nil </span><span class="cov0" title="0">{
                ext.Error.Set(span, true)
                span.SetTag("error", err.Error())
        }</span> else<span class="cov0" title="0"> {
                span.SetTag("response", res)
        }</span>

        <span class="cov0" title="0">return res, err</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package jwt_manager

import (
        "fmt"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/golang-jwt/jwt"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
)

// AuthClient implements the AuthHelper interface and provides methods for
// managing authentication tasks, including token generation and password handling.
type AuthClient struct {
        secretKey            []byte        // Secret key used for signing tokens
        refreshTokenDuration time.Duration // Duration for which the refresh token is valid
        accessTokenDuration  time.Duration // Duration for which the access token is valid
}

// New creates a new AuthClient instance with the provided secret key and token durations.
// It returns an AuthHelper interface implementation for managing authentication tasks.
func New(secretKey []byte, refreshTokenDuration time.Duration, accessTokenDuration time.Duration) AuthHelper <span class="cov0" title="0">{
        return &amp;AuthClient{
                secretKey:            secretKey,
                refreshTokenDuration: refreshTokenDuration,
                accessTokenDuration:  accessTokenDuration,
        }
}</span>

// GenerateAccessToken creates a new access token for a user based on the provided access token information.
// It sets the expiration time for the token and returns the signed token as a string.
func (a *AuthClient) GenerateAccessToken(info *model.AccessTokenInfo) (string, error) <span class="cov0" title="0">{
        claims := model.UserClaims{
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(a.accessTokenDuration).Unix(),
                },
                ID:   info.ID,
                Role: info.Role,
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(a.secretKey)
}</span>

// GenerateRefreshToken creates a new refresh token for a user identified by their user ID.
// The token will have an expiration time set according to the specified duration.
func (a *AuthClient) GenerateRefreshToken(userID int) (string, error) <span class="cov0" title="0">{
        claims := model.UserClaims{
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(a.refreshTokenDuration).Unix(),
                },
                ID: userID,
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(a.secretKey)
}</span>

// VerifyToken checks the validity of the provided JWT token. It parses the token and extracts the claims,
// returning them if the token is valid. An error is returned if the token is invalid or expired.
func (a *AuthClient) VerifyToken(token string) (*model.UserClaims, error) <span class="cov0" title="0">{
        tokenClaims, err := jwt.ParseWithClaims(token, &amp;model.UserClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                _, ok := token.Method.(*jwt.SigningMethodHMAC)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return a.secretKey, nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">claims, ok := tokenClaims.Claims.(*model.UserClaims)
        if !ok || !tokenClaims.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>
        <span class="cov0" title="0">return claims, nil</span>
}

// HashPassword generates a hashed version of the provided password using bcrypt.
// It returns the hashed password as a string or an error if the hashing fails.
func (a *AuthClient) HashPassword(password string) (string, error) <span class="cov0" title="0">{
        const mark = "JwtManager.Init.HashPassword"

        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to hash password", mark, zap.Error(err))
                return "", err
        }</span>
        <span class="cov0" title="0">return string(hashedPassword), nil</span>
}

// ValidatePassword compares a hashed password with a candidate password to verify their equality.
// It returns true if they match, or false otherwise.
func (a *AuthClient) ValidatePassword(hashedPassword, candidatePassword string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(candidatePassword))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

// Constants for Prometheus metric identification.
const (
        namespace = "auth_service_space" // Metric namespace.
        appName   = "auth_service"       // Application name.
        subsystem = "grpc"               // Application subsystem.
)

// NewCounter creates a Prometheus counter metric.
// name: Metric name. description: Metric description.
func NewCounter(name, description string) prometheus.Counter <span class="cov0" title="0">{
        return promauto.NewCounter(prometheus.CounterOpts{
                Namespace: namespace,
                Subsystem: subsystem,
                Name:      appName + "_" + name,
                Help:      description,
        })
}</span>

// NewCounterVec creates a Prometheus counter vector.
// name: Metric name. description: Metric description. labels: Metric labels.
func NewCounterVec(name, description string, labels []string) *prometheus.CounterVec <span class="cov0" title="0">{
        return promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: namespace,
                Subsystem: subsystem,
                Name:      appName + "_" + name,
                Help:      description,
        }, labels)
}</span>

// NewHistogramVec creates a Prometheus histogram vector.
// name: Metric name. description: Metric description.
// buckets: Histogram buckets. labels: Metric labels.
func NewHistogramVec(
        name, description string, buckets []float64, labels []string,
) *prometheus.HistogramVec <span class="cov0" title="0">{
        return promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: namespace,
                Subsystem: subsystem,
                Name:      appName + "_" + name,
                Help:      description,
                Buckets:   buckets,
        }, labels)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package metrics

import (
        "context"

        "github.com/prometheus/client_golang/prometheus"
)

// Constants for Prometheus metrics configuration

// Metrics structure contains all the Prometheus metrics for the service
type Metrics struct {
        requestCounter        prometheus.Counter
        registrationCounter   prometheus.Counter
        verificationCounter   prometheus.Counter
        responseCounter       *prometheus.CounterVec
        histogramResponseTime *prometheus.HistogramVec
}

// Global variable to hold the metrics object
var metrics *Metrics

// Init  Initializes Prometheus metrics
func Init(_ context.Context) error <span class="cov0" title="0">{
        metrics = &amp;Metrics{
                requestCounter:      NewCounter("requests_total", "Total number of requests."),
                registrationCounter: NewCounter("registrations_total", "Total number of registrations."),
                verificationCounter: NewCounter("verifications_total", "Total number of verifications."),
                responseCounter:     NewCounterVec("responses_total", "Total number of responses.", []string{"status", "method"}),
                histogramResponseTime: NewHistogramVec("response_time_second",
                        "Request execution time.", prometheus.ExponentialBuckets(0.001, 2, 16),
                        []string{"status"}),
        }

        return nil
}</span>

// IncRequestCounter Increments the total request counter
func IncRequestCounter() <span class="cov0" title="0">{
        metrics.requestCounter.Inc()
}</span>

// IncRegistrationCounter Increments the total registration counter
func IncRegistrationCounter() <span class="cov0" title="0">{
        metrics.registrationCounter.Inc()
}</span>

// IncVerificationCounter Increments the total verification counter
func IncVerificationCounter() <span class="cov0" title="0">{
        metrics.verificationCounter.Inc()
}</span>

// IncResponseCounter Increments the response counter with status and method labels
func IncResponseCounter(status, method string) <span class="cov0" title="0">{
        metrics.responseCounter.WithLabelValues(status, method).Inc()
}</span>

// ObserveResponseTime Observes the response time and records it in the histogram
func ObserveResponseTime(status string, time float64) <span class="cov0" title="0">{
        metrics.histogramResponseTime.WithLabelValues(status).Observe(time)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package ratelimiter

import (
        "context"
        "time"
)

// TokenBucketLimiter implements a rate limiter using the token bucket algorithm.
type TokenBucketLimiter struct {
        tokenBucket chan struct{} // Channel to store available tokens.
}

// NewTokenBucketLimiter creates a new TokenBucketLimiter with the specified limit and period.
// Tokens are replenished at regular intervals to maintain the defined rate limit.
func NewTokenBucketLimiter(ctx context.Context, limit int, period time.Duration) *TokenBucketLimiter <span class="cov0" title="0">{
        limiter := &amp;TokenBucketLimiter{
                tokenBucket: make(chan struct{}, limit),
        }

        // Fill the token bucket initially with the maximum allowed tokens.
        for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                limiter.tokenBucket &lt;- struct{}{}
        }</span>

        // Calculate the replenishment interval and start periodic token replenishment.
        <span class="cov0" title="0">replenishmentInterval := period.Nanoseconds() / int64(limit)
        go limiter.startPeriodicReplenishment(ctx, time.Duration(replenishmentInterval))

        return limiter</span>
}

// startPeriodicReplenishment periodically adds tokens to the bucket at the specified interval.
func (l *TokenBucketLimiter) startPeriodicReplenishment(ctx context.Context, replenishmentInterval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(replenishmentInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"> // Stop replenishment when the context is canceled.
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0"> // Add a token to the bucket at each tick.
                        l.tokenBucket &lt;- struct{}{}</span>
                }
        }
}

// Allow attempts to consume a token from the bucket and returns true if successful.
// Returns false if the bucket is empty, indicating the limit has been reached.
func (l *TokenBucketLimiter) Allow() bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-l.tokenBucket:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package auth

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"
)

// ConfirmEmail updates the user's email verification status to confirmed in the database.
// It accepts a context and the user's email as parameters and returns an error if any issues occur.
func (a *RepositoryAuth) ConfirmEmail(ctx context.Context, email string) error <span class="cov0" title="0">{

        const mark = "Repository.Auth.ConfirmEmail"

        queryBuilder := squirrel.Update(TableName).
                PlaceholderFormat(squirrel.Dollar).
                Set(Verification, true).
                Where(squirrel.Eq{EmailColumn: email})

        query, args, err := queryBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build query", mark, zap.Error(err))
                return fmt.Errorf("failed to build query: %v", err)
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "Confirm Email",
                QueryRaw: query,
        }

        res, err := a.db.DB().ExecContext(ctx, q, args...)
        fmt.Println(res)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to confirm email", mark, zap.Error(err))
                return fmt.Errorf("failed to confirm email: %v", err)
        }</span>

        <span class="cov0" title="0">rowsAffected := res.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Error("user not found", mark, zap.Error(err))
                return fmt.Errorf("user not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package auth

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"
)

// GetAccessToken retrieves the access token information for a given user ID.
// It first attempts to get the user's role from Redis.
// If the role is not found in Redis, it queries the database to retrieve it.
// The role is then cached in Redis for future access.
func (a *RepositoryAuth) GetAccessToken(ctx context.Context, userID int) (*model.AccessTokenInfo, error) <span class="cov0" title="0">{

        const mark = "Repository.Auth.GetAccessToken"

        val, err := a.redisClient.Get(ctx, strconv.Itoa(userID)+" for role")
        if nil == err </span><span class="cov0" title="0">{
                return &amp;model.AccessTokenInfo{
                        ID:   userID,
                        Role: val,
                }, nil
        }</span>

        <span class="cov0" title="0">queryBuilder := squirrel.Select(RoleColumn).
                From(TableName).
                PlaceholderFormat(squirrel.Dollar).
                Where(squirrel.Eq{IDColumn: userID}).
                Limit(1)

        query, args, err := queryBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build query", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to build query: %v", err)
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "GetAccessToken",
                QueryRaw: query,
        }

        var role string
        err = a.db.DB().ScanOneContext(ctx, &amp;role, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get role from db", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to get role from db: %v", err)
        }</span>

        <span class="cov0" title="0">err = a.redisClient.Set(ctx, strconv.Itoa(userID)+" for role", role, 24*time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to set role in redis", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to set role in redis: %v", err)
        }</span>

        <span class="cov0" title="0">logger.Debug("getting user role from database", mark, zap.String("User role", role))

        return &amp;model.AccessTokenInfo{
                ID:   userID,
                Role: role,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package auth

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/redis"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
)

// IRepositoryAuth defines the interface for authentication-related database and Redis operations.
type IRepositoryAuth interface {
        // Registration saves a new user's registration information to the database.
        // It returns the user's ID upon successful registration or an error if the operation fails.
        Registration(ctx context.Context, registrationRequest *model.InfoToDb) (int, error)

        // Login retrieves a user's login information based on their email.
        // It returns a LoginResponse containing the user's credentials or an error if the operation fails.
        Login(ctx context.Context, email string) (*model.LoginResponse, error)

        // GetAccessToken fetches access token information for a user identified by their user ID.
        // It returns the AccessTokenInfo struct containing relevant token details or an error if the operation fails.
        GetAccessToken(ctx context.Context, userID int) (*model.AccessTokenInfo, error)

        // UpdatePassword updates the user's password in the database.
        // It takes a UpdatePassDb struct with the user's email and new hashed password,
        // and returns an error if the operation fails.
        UpdatePassword(ctx context.Context, updatePassDb *model.UpdatePassDb) error

        // ConfirmEmail sends a confirmation email to the user with the provided email address.
        // It returns an error if the email sending operation fails.
        ConfirmEmail(ctx context.Context, email string) error
}

// RepositoryAuth provides methods for authentication-related database and Redis operations.
type RepositoryAuth struct {
        db          db.Client    // Database client for executing queries.
        redisClient redis.IRedis // Redis client for cache operations.
}

// New creates a new instance of AuthRepository with provided database and Redis clients.
func New(db db.Client, redisClient redis.IRedis) IRepositoryAuth <span class="cov0" title="0">{
        return &amp;RepositoryAuth{
                db:          db,
                redisClient: redisClient,
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package auth

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"
)

// Login retrieves the user's login information by email, checking Redis first for cached data.
func (a *RepositoryAuth) Login(ctx context.Context, email string) (*model.LoginResponse, error) <span class="cov0" title="0">{

        const mark = "Repository.Auth.Login"

        logger.Debug("getting email in repository", mark, zap.String("EMAIL", email))

        var loginResponse model.LoginResponse
        err := a.redisClient.GetObject(ctx, email, &amp;loginResponse)
        if nil == err </span><span class="cov0" title="0">{
                logger.Info("found user in redis", mark, zap.Any("user", loginResponse))
                return &amp;loginResponse, nil
        }</span>

        <span class="cov0" title="0">queryBuilder := squirrel.Select(IDColumn, HashPasswordColumn, RoleColumn).
                From(TableName).
                PlaceholderFormat(squirrel.Dollar).
                Where(squirrel.Eq{EmailColumn: email}).
                Limit(1)

        query, args, err := queryBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build query", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to build query: %v", err)
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "Login",
                QueryRaw: query,
        }

        err = a.db.DB().ScanOneContext(ctx, &amp;loginResponse, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "no rows in result set") </span><span class="cov0" title="0">{
                        logger.Debug("failed to get user from db", mark, zap.Error(err))
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">logger.Error("failed to get user from db", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to get user from db: %v", err)</span>
        }

        <span class="cov0" title="0">err = a.redisClient.SetObject(ctx, email, loginResponse, 15*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to set user role in redis", mark, zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;loginResponse, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package auth

import (
        "context"
        "fmt"
        "strings"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/metrics"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"
)

// Registration inserts a new user into the database and returns the user ID.
func (a *RepositoryAuth) Registration(ctx context.Context, infoToDb *model.InfoToDb) (int, error) <span class="cov0" title="0">{

        const mark = "Repository.Auth.Registration"

        builderInsert := squirrel.Insert(TableName).
                PlaceholderFormat(squirrel.Dollar).
                Columns(EmailColumn, HashPasswordColumn, RoleColumn).
                Values(infoToDb.Email, infoToDb.HashPassword, infoToDb.Role).
                Suffix(ReturningID)

        query, args, err := builderInsert.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build insert query", mark, zap.Error(err))
                return 0, fmt.Errorf("failed to build insert query: %v", err)
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "Registration",
                QueryRaw: query,
        }

        var ID int
        err = a.db.DB().QueryRowContext(ctx, q, args...).Scan(&amp;ID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov0" title="0">{
                        logger.Warn("email already registered", mark, zap.Error(err))
                        return 0, fmt.Errorf("email already registered")
                }</span>

                <span class="cov0" title="0">logger.Error("failed to register user", mark, zap.Error(err))
                return 0, fmt.Errorf("failed to register user: %v", err)</span>
        }

        <span class="cov0" title="0">metrics.IncRegistrationCounter()

        return ID, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package auth

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"
)

// UpdatePassword updates the password of a user in the database based on their email address.
// The function builds an SQL update query to set the new hashed password and updated timestamp.
// If the query fails to build, an error is logged and returned. After executing the query,
// if no rows are affected, it logs a warning indicating the user was not found.
// If the update is successful, it attempts to delete the users cached data from Redis.
// Any errors encountered while interacting with Redis are logged but not returned.
func (a *RepositoryAuth) UpdatePassword(ctx context.Context, updatePassDb *model.UpdatePassDb) error <span class="cov0" title="0">{

        const mark = "Repository.Auth.UpdatePassword"

        queryBuilder := squirrel.Update(TableName).
                PlaceholderFormat(squirrel.Dollar).
                Set(HashPasswordColumn, updatePassDb.HashPassword).
                Set(UpdatedAtColumn, updatePassDb.UpdatedAt).
                Where(squirrel.Eq{EmailColumn: updatePassDb.Email})

        query, args, err := queryBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build query", mark, zap.Error(err))
                return fmt.Errorf("failed to build query: %v", err)
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "UpdatePassword",
                QueryRaw: query,
        }

        res, err := a.db.DB().ExecContext(ctx, q, args...)
        fmt.Println(res)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update password", mark, zap.Error(err))
                return fmt.Errorf("failed to update password: %v", err)
        }</span>

        <span class="cov0" title="0">rowsAffected := res.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("user not found", mark, zap.String("email", updatePassDb.Email))
                return fmt.Errorf("user not found")
        }</span>

        <span class="cov0" title="0">err = a.redisClient.Delete(ctx, updatePassDb.Email)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete user from redis", mark, zap.Error(err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package events

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"
)

// CompleteEvents updates the status of events with the provided IDs to "complete".
func (e *EventRepository) CompleteEvents(ctx context.Context, completeIDs []int) error <span class="cov0" title="0">{

        const mark = "Repository.Events.CompleteEvents"

        updateBuilder := squirrel.Update("outbox").
                PlaceholderFormat(squirrel.Dollar).
                Set("status", "complete").
                Where(squirrel.Eq{IDColumn: completeIDs})

        query, args, err := updateBuilder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build update query", mark, zap.Error(err))
                return fmt.Errorf("failed to build update query: %v", err)
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "CompleteEvents",
                QueryRaw: query,
        }

        _, err = e.db.DB().ExecContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to complete events", mark, zap.Error(err))
                return fmt.Errorf("failed to complete events: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package events

import (
        "context"

        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
)

// GetEvents retrieves up to 10 pending events from the outbox table.
func (e *EventRepository) GetEvents(ctx context.Context) ([]model.EventData, error) <span class="cov0" title="0">{

        const mark = "Repository.Events.GetEvents"

        builderSelect := squirrel.
                Select(IDColumn, EventColumn, PayloadColumn, CreatedAtColumn).
                PlaceholderFormat(squirrel.Dollar).
                From(TableNameOutbox).
                Where(squirrel.Eq{StatusColumn: "pending"}).
                Limit(10)

        query, args, err := builderSelect.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build select query", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "GetEvents",
                QueryRaw: query,
        }

        rows, err := e.db.DB().QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get events", mark, zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []model.EventData
        for rows.Next() </span><span class="cov0" title="0">{
                var event model.EventData
                if err := rows.Scan(&amp;event.ID, &amp;event.Event, &amp;event.Payload, &amp;event.CreatedAt); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to scan row", mark, zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package events

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
)

// IEventRepository defines the interface for event-related operations.
type IEventRepository interface {
        // SendEvent inserts a new event into the database.
        SendEvent(ctx context.Context, event *model.SendEvent) error

        // GetEvents retrieves pending events from the database.
        GetEvents(ctx context.Context) ([]model.EventData, error)

        // CompleteEvents marks events with specified IDs as completed in the database.
        CompleteEvents(ctx context.Context, completeIDs []int) error
}

// EventRepository is the concrete implementation of IEventRepository.
type EventRepository struct {
        db db.Client // Database client for executing queries.
}

// New creates a new instance of EventRepository.
func New(db db.Client) IEventRepository <span class="cov0" title="0">{
        return &amp;EventRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package events

import (
        "context"
        "fmt"

        "github.com/Masterminds/squirrel"
        "go.uber.org/zap"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
)

// SendEvent inserts a new event into the outbox table.
func (e *EventRepository) SendEvent(ctx context.Context, event *model.SendEvent) error <span class="cov0" title="0">{

        const mark = "Repository.Events.SendEvent"

        builderInsert := squirrel.Insert(TableNameOutbox).PlaceholderFormat(squirrel.Dollar).
                Columns(EventColumn, PayloadColumn).
                Values(event.Event, event.Payload)

        query, args, err := builderInsert.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to build insert query", mark, zap.Error(err))
                return fmt.Errorf("failed to build insert query: %v", err)
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "SendEvent",
                QueryRaw: query,
        }

        _, err = e.db.DB().ExecContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to send event", mark, zap.Error(err))
                return fmt.Errorf("failed to send event: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package repository

import (
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/redis"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/auth"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/events"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
)

// Repository provides database access for data operations.
type Repository struct {
        Auth  auth.IRepositoryAuth
        Event events.IEventRepository
}

// New creates a new Repository instance with the given database client.
func New(db db.Client, redisClient redis.IRedis) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                Auth:  auth.New(db, redisClient),
                Event: events.New(db),
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package auth

import (
        "context"
)

// ConfirmEmail is a service method that handles the email confirmation process.
// It calls the repository layer to update the email verification status.
func (s *ServiceAuth) ConfirmEmail(ctx context.Context, mail string) error <span class="cov10" title="10">{
        return s.Repo.Auth.ConfirmEmail(ctx, mail)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package auth

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "go.uber.org/zap"
)

// GetAccessToken generates a new access token and refresh token based on the provided refresh token.
func (s *ServiceAuth) GetAccessToken(ctx context.Context, refreshToken string) (*model.NewPairTokens, error) <span class="cov10" title="25">{

        const mark = "Service.Auth.GetAccessToken"

        logger.Debug("getting refresh token on service", mark, zap.String("REFRESH_TOKEN", refreshToken))

        claims, err := s.AuthHelper.VerifyToken(refreshToken)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to verify token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to verify token: %v", err)
        }</span>

        <span class="cov9" title="20">info, err := s.Repo.Auth.GetAccessToken(ctx, claims.ID)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to get access token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to get access token: %v", err)
        }</span>
        <span class="cov8" title="15">access, err := s.AuthHelper.GenerateAccessToken(info)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to generate access token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to generate access token: %v", err)
        }</span>

        <span class="cov7" title="10">refresh, err := s.AuthHelper.GenerateRefreshToken(info.ID)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to generate refresh token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to generate refresh token: %v", err)
        }</span>

        <span class="cov5" title="5">return &amp;model.NewPairTokens{AccessToken: access, RefreshToken: refresh}, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package auth

import (
        "context"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/jwt_manager"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
)

// IServiceAuth defines the interface for authentication-related operations.
type IServiceAuth interface {
        // Registration creates a new user account with the provided registration details.
        // It returns an AuthResponse containing tokens if successful, or an error if the registration fails.
        Registration(ctx context.Context, registrationRequest *model.UserInfo) (*model.AuthResponse, error)

        // Login authenticates a user using their login credentials.
        // It returns an AuthResponse containing tokens if successful, or an error if login fails.
        Login(ctx context.Context, loginRequest *model.LoginInfo) (*model.AuthResponse, error)

        // GetAccessToken generates a new access token using the provided refresh token.
        // It returns a NewPairTokens containing the new access and refresh tokens, or an error if the operation fails.
        GetAccessToken(ctx context.Context, refreshToken string) (*model.NewPairTokens, error)

        // ValidateToken checks the validity of the provided access token.
        // It returns true if the token is valid, along with any error encountered during validation.
        ValidateToken(ctx context.Context, accessToken string) (bool, error)

        // UpdatePassword changes the password for the user associated with the provided information.
        // It returns an error if the password update operation fails.
        UpdatePassword(ctx context.Context, updatePassInfo *model.UpdatePassInfo) error

        // ConfirmEmail sends a confirmation email to the user with the provided email address.
        // It returns an error if the email sending operation fails.
        ConfirmEmail(ctx context.Context, email string) error
}

// ServiceAuth provides authentication-related services, including repository interactions, JWT management, and transaction management.
type ServiceAuth struct {
        Repo       *repository.Repository
        AuthHelper jwt_manager.AuthHelper
        Tx         db.TxManager
}

// New creates a new instance of AuthService with the provided repository, JWT helper, and transaction manager.
func New(repo *repository.Repository, authHelper jwt_manager.AuthHelper, tx db.TxManager) IServiceAuth <span class="cov0" title="0">{
        return &amp;ServiceAuth{
                Repo:       repo,
                AuthHelper: authHelper,
                Tx:         tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package auth

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "go.uber.org/zap"
)

// Login authenticates a user with the provided login information and generates access and refresh tokens.
func (s *ServiceAuth) Login(ctx context.Context, loginInfo *model.LoginInfo) (*model.AuthResponse, error) <span class="cov10" title="25">{

        const mark = "Service.Auth.Login"

        logger.Debug("get data in service", mark, zap.Any("loginInfo", loginInfo))

        result, err := s.Repo.Auth.Login(ctx, loginInfo.Email)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to login", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov9" title="20">ok := s.AuthHelper.ValidatePassword(result.HashPassword, loginInfo.Password)
        if !ok </span><span class="cov5" title="5">{
                logger.Error("invalid password", mark, zap.Error(err))
                return nil, fmt.Errorf("invalid password")
        }</span>

        <span class="cov8" title="15">accessToken, err := s.AuthHelper.GenerateAccessToken(&amp;model.AccessTokenInfo{
                ID:   result.UserID,
                Role: result.Role,
        })
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to generate access token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to generate access token: %v", err)
        }</span>

        <span class="cov7" title="10">refreshToken, err := s.AuthHelper.GenerateRefreshToken(result.UserID)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to generate refresh token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to generate refresh token: %v", err)
        }</span>

        <span class="cov5" title="5">logger.Debug("new pair tokens in service: ", mark, zap.Any("tokens", result))

        return converter.ToModelAuthResponse(accessToken, refreshToken, result.UserID), nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package auth

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/goccy/go-json"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "go.uber.org/zap"
)

var (
        topicRegistration = "registration"
)

// Registration handles the registration of a new user, hashes their password,
// and generates access and refresh tokens upon successful registration.
func (s *ServiceAuth) Registration(ctx context.Context, userInfo *model.UserInfo) (*model.AuthResponse, error) <span class="cov10" title="25">{

        const mark = "Service.Auth.Registration"

        HashedPassword, err := s.AuthHelper.HashPassword(userInfo.Password)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to hash password", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to hash password: %v", err)
        }</span>

        <span class="cov9" title="20">var UserID int
        err = s.Tx.ReadCommitted(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                var errTx error
                UserID, errTx = s.Repo.Auth.Registration(ctx, converter.FromUserInfoToDbModel(userInfo, HashedPassword))
                if errTx != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to registration", mark, zap.Error(err))
                        return errTx
                }</span>

                <span class="cov0" title="0">payload, errTx := json.Marshal(converter.ToModelPayload(topicRegistration, UserID, userInfo))
                if errTx != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to marshal", mark, zap.Error(err))
                        return errTx
                }</span>

                <span class="cov0" title="0">errTx = s.Repo.Event.SendEvent(ctx, converter.ToModelSendEvent(topicRegistration, payload))
                if errTx != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to send event", mark, zap.Error(err))
                        return errTx
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov9" title="20">if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to registration", mark, zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="15">accessToken, err := s.AuthHelper.GenerateAccessToken(converter.ToModelAccessTokenInfo(UserID, userInfo))
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to generate access token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to generate access token: %v", err)
        }</span>

        <span class="cov7" title="10">refreshToken, err := s.AuthHelper.GenerateRefreshToken(UserID)
        if err != nil </span><span class="cov5" title="5">{
                logger.Error("failed to generate refresh token", mark, zap.Error(err))
                return nil, fmt.Errorf("failed to generate refresh token: %v", err)
        }</span>

        <span class="cov5" title="5">return converter.ToModelAuthResponse(accessToken, refreshToken, UserID), nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package auth

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/converter"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "go.uber.org/zap"
)

// UpdatePassword hashes the new password and updates the user's password in the database.
func (s *ServiceAuth) UpdatePassword(ctx context.Context, updatePassInfo *model.UpdatePassInfo) error <span class="cov10" title="15">{

        const mark = "Service.Auth.UpdatePassword"

        logger.Debug("get data in service", mark, zap.Any("updatePassInfo", updatePassInfo))

        hashPassword, err := s.AuthHelper.HashPassword(updatePassInfo.NewPassword)
        if err != nil </span><span class="cov6" title="5">{
                logger.Error("failed to hash password", mark, zap.Error(err))
                return fmt.Errorf("failed to hash password: %v", err)
        }</span>
        <span class="cov8" title="10">err = s.Repo.Auth.UpdatePassword(ctx, converter.FromUpdatePassInfoToDbPassInfo(updatePassInfo, hashPassword))
        if err != nil </span><span class="cov6" title="5">{
                logger.Error("failed to update password", mark, zap.Error(err))
                return fmt.Errorf("failed to update password: %v", err)
        }</span>

        <span class="cov6" title="5">logger.Debug("password updated", mark, zap.Any("updatePassInfo", updatePassInfo))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package auth

import (
        "context"
        "fmt"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"

        "go.uber.org/zap"
)

// ValidateToken verifies the access token and returns true if valid.
func (s *ServiceAuth) ValidateToken(_ context.Context, accessToken string) (bool, error) <span class="cov10" title="10">{

        const mark = "Service.Auth.ValidateToken"

        logger.Debug("get access token in service", mark, zap.String("ACCESS_TOKEN", accessToken))

        _, err := s.AuthHelper.VerifyToken(accessToken)
        if err != nil </span><span class="cov7" title="5">{
                logger.Error("failed to verify token", mark, zap.Error(err))
                return false, fmt.Errorf("failed to verify token: %v", err)
        }</span>
        <span class="cov7" title="5">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package eventsender

import (
        "context"
        "time"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/metrics"

        "github.com/goccy/go-json"
        "go.uber.org/zap"

        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/kafka"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/model"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository/events"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/logger"
)

// ISender defines the interface for sending events at regular intervals.
type ISender interface {
        // Start begins the process of fetching and sending events at a specified interval.
        Start(ctx context.Context, period time.Duration)
}

// Sender is responsible for sending events to a Kafka producer and marking them as complete.
type Sender struct {
        producer kafka.IProducer         // Kafka producer to send events.
        db       db.Client               // Database client for accessing event repository.
        repo     events.IEventRepository // Event repository for fetching and completing events.
}

// New creates a new Sender instance with the provided Kafka producer, database client, and event repository.
func New(producer kafka.IProducer, db db.Client, repo events.IEventRepository) *Sender <span class="cov0" title="0">{
        return &amp;Sender{
                producer: producer,
                db:       db,
                repo:     repo,
        }
}</span>

// Start starts a loop to fetch events periodically and send them to Kafka.
func (s *Sender) Start(ctx context.Context, period time.Duration) <span class="cov0" title="0">{
        const mark = "Service.EventSender.Start"

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        // Fetch events from the repository
                        data, err := s.repo.GetEvents(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to get events", mark, zap.Error(err))
                                continue</span>
                        }

                        // If no events, continue to next cycle
                        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Send events to Kafka and get their IDs for completion
                        <span class="cov0" title="0">ids := SendEvents(data, s)

                        // Mark events as completed in the repository
                        err = s.repo.CompleteEvents(ctx, ids)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to complete events", mark, zap.Error(err))
                                continue</span>
                        }

                        // Wait for the specified period or termination signal
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(period):<span class="cov0" title="0"></span>
                        }
                }
        }()
}

// SendEvents processes the fetched events, sends them to Kafka, and returns the IDs of successfully processed events.
func SendEvents(data []model.EventData, s *Sender) []int <span class="cov0" title="0">{
        const mark = "Service.EventSender.SendEvents"

        successIDs := make([]int, 0)
        for _, event := range data </span><span class="cov0" title="0">{
                var payload model.Payload

                // Unmarshal the event payload
                if err := json.Unmarshal([]byte(event.Payload), &amp;payload); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to unmarshal payload", mark, zap.Error(err))
                        continue</span>
                }

                // Produce the event to Kafka
                <span class="cov0" title="0">if err := s.producer.Produce(payload.Message, payload.Topic, payload.Key); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to produce event", mark, zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">metrics.IncVerificationCounter()
                successIDs = append(successIDs, event.ID)</span>
        }
        <span class="cov0" title="0">return successIDs</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package service

import (
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/clients/kafka"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/jwt_manager"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/repository"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/auth"
        eventSender "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/internal/service/event_sender"
        "github.com/AwesomeXjs/registration-service-with-checking-mail/auth-service/pkg/db"
)

// Service provides business logic and interacts with the repository.
type Service struct {
        Auth  auth.IServiceAuth
        Event eventSender.ISender
}

// New creates a new Service instance with the given repository.
func New(repo *repository.Repository,
        authHelper jwt_manager.AuthHelper,
        tx db.TxManager,
        producer kafka.IProducer,
        db db.Client) *Service <span class="cov0" title="0">{
        return &amp;Service{
                Auth: auth.New(repo, authHelper, tx),
                Event: eventSender.New(
                        producer,
                        db,
                        repo.Event,
                ),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

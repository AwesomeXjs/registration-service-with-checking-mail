// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/AwesomeXjs/registration-service-with-checking-mail/server/api-gateway-auth/internal/utils/header_helper.IHeaderHelper -o i_header_helper_minimock.go -n IHeaderHelperMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/labstack/echo/v4"
)

// IHeaderHelperMock implements mm_header_helper.IHeaderHelper
type IHeaderHelperMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAccessTokenFromHeader          func(ctx echo.Context) (s1 string, err error)
	funcGetAccessTokenFromHeaderOrigin    string
	inspectFuncGetAccessTokenFromHeader   func(ctx echo.Context)
	afterGetAccessTokenFromHeaderCounter  uint64
	beforeGetAccessTokenFromHeaderCounter uint64
	GetAccessTokenFromHeaderMock          mIHeaderHelperMockGetAccessTokenFromHeader

	funcGetRefreshTokenFromCookie          func(ctx echo.Context, key string) (s1 string, err error)
	funcGetRefreshTokenFromCookieOrigin    string
	inspectFuncGetRefreshTokenFromCookie   func(ctx echo.Context, key string)
	afterGetRefreshTokenFromCookieCounter  uint64
	beforeGetRefreshTokenFromCookieCounter uint64
	GetRefreshTokenFromCookieMock          mIHeaderHelperMockGetRefreshTokenFromCookie

	funcSetRefreshTokenInCookie          func(ctx echo.Context, key string, value string)
	funcSetRefreshTokenInCookieOrigin    string
	inspectFuncSetRefreshTokenInCookie   func(ctx echo.Context, key string, value string)
	afterSetRefreshTokenInCookieCounter  uint64
	beforeSetRefreshTokenInCookieCounter uint64
	SetRefreshTokenInCookieMock          mIHeaderHelperMockSetRefreshTokenInCookie
}

// NewIHeaderHelperMock returns a mock for mm_header_helper.IHeaderHelper
func NewIHeaderHelperMock(t minimock.Tester) *IHeaderHelperMock {
	m := &IHeaderHelperMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAccessTokenFromHeaderMock = mIHeaderHelperMockGetAccessTokenFromHeader{mock: m}
	m.GetAccessTokenFromHeaderMock.callArgs = []*IHeaderHelperMockGetAccessTokenFromHeaderParams{}

	m.GetRefreshTokenFromCookieMock = mIHeaderHelperMockGetRefreshTokenFromCookie{mock: m}
	m.GetRefreshTokenFromCookieMock.callArgs = []*IHeaderHelperMockGetRefreshTokenFromCookieParams{}

	m.SetRefreshTokenInCookieMock = mIHeaderHelperMockSetRefreshTokenInCookie{mock: m}
	m.SetRefreshTokenInCookieMock.callArgs = []*IHeaderHelperMockSetRefreshTokenInCookieParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIHeaderHelperMockGetAccessTokenFromHeader struct {
	optional           bool
	mock               *IHeaderHelperMock
	defaultExpectation *IHeaderHelperMockGetAccessTokenFromHeaderExpectation
	expectations       []*IHeaderHelperMockGetAccessTokenFromHeaderExpectation

	callArgs []*IHeaderHelperMockGetAccessTokenFromHeaderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IHeaderHelperMockGetAccessTokenFromHeaderExpectation specifies expectation struct of the IHeaderHelper.GetAccessTokenFromHeader
type IHeaderHelperMockGetAccessTokenFromHeaderExpectation struct {
	mock               *IHeaderHelperMock
	params             *IHeaderHelperMockGetAccessTokenFromHeaderParams
	paramPtrs          *IHeaderHelperMockGetAccessTokenFromHeaderParamPtrs
	expectationOrigins IHeaderHelperMockGetAccessTokenFromHeaderExpectationOrigins
	results            *IHeaderHelperMockGetAccessTokenFromHeaderResults
	returnOrigin       string
	Counter            uint64
}

// IHeaderHelperMockGetAccessTokenFromHeaderParams contains parameters of the IHeaderHelper.GetAccessTokenFromHeader
type IHeaderHelperMockGetAccessTokenFromHeaderParams struct {
	ctx echo.Context
}

// IHeaderHelperMockGetAccessTokenFromHeaderParamPtrs contains pointers to parameters of the IHeaderHelper.GetAccessTokenFromHeader
type IHeaderHelperMockGetAccessTokenFromHeaderParamPtrs struct {
	ctx *echo.Context
}

// IHeaderHelperMockGetAccessTokenFromHeaderResults contains results of the IHeaderHelper.GetAccessTokenFromHeader
type IHeaderHelperMockGetAccessTokenFromHeaderResults struct {
	s1  string
	err error
}

// IHeaderHelperMockGetAccessTokenFromHeaderOrigins contains origins of expectations of the IHeaderHelper.GetAccessTokenFromHeader
type IHeaderHelperMockGetAccessTokenFromHeaderExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) Optional() *mIHeaderHelperMockGetAccessTokenFromHeader {
	mmGetAccessTokenFromHeader.optional = true
	return mmGetAccessTokenFromHeader
}

// Expect sets up expected params for IHeaderHelper.GetAccessTokenFromHeader
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) Expect(ctx echo.Context) *mIHeaderHelperMockGetAccessTokenFromHeader {
	if mmGetAccessTokenFromHeader.mock.funcGetAccessTokenFromHeader != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("IHeaderHelperMock.GetAccessTokenFromHeader mock is already set by Set")
	}

	if mmGetAccessTokenFromHeader.defaultExpectation == nil {
		mmGetAccessTokenFromHeader.defaultExpectation = &IHeaderHelperMockGetAccessTokenFromHeaderExpectation{}
	}

	if mmGetAccessTokenFromHeader.defaultExpectation.paramPtrs != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("IHeaderHelperMock.GetAccessTokenFromHeader mock is already set by ExpectParams functions")
	}

	mmGetAccessTokenFromHeader.defaultExpectation.params = &IHeaderHelperMockGetAccessTokenFromHeaderParams{ctx}
	mmGetAccessTokenFromHeader.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAccessTokenFromHeader.expectations {
		if minimock.Equal(e.params, mmGetAccessTokenFromHeader.defaultExpectation.params) {
			mmGetAccessTokenFromHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccessTokenFromHeader.defaultExpectation.params)
		}
	}

	return mmGetAccessTokenFromHeader
}

// ExpectCtxParam1 sets up expected param ctx for IHeaderHelper.GetAccessTokenFromHeader
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) ExpectCtxParam1(ctx echo.Context) *mIHeaderHelperMockGetAccessTokenFromHeader {
	if mmGetAccessTokenFromHeader.mock.funcGetAccessTokenFromHeader != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("IHeaderHelperMock.GetAccessTokenFromHeader mock is already set by Set")
	}

	if mmGetAccessTokenFromHeader.defaultExpectation == nil {
		mmGetAccessTokenFromHeader.defaultExpectation = &IHeaderHelperMockGetAccessTokenFromHeaderExpectation{}
	}

	if mmGetAccessTokenFromHeader.defaultExpectation.params != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("IHeaderHelperMock.GetAccessTokenFromHeader mock is already set by Expect")
	}

	if mmGetAccessTokenFromHeader.defaultExpectation.paramPtrs == nil {
		mmGetAccessTokenFromHeader.defaultExpectation.paramPtrs = &IHeaderHelperMockGetAccessTokenFromHeaderParamPtrs{}
	}
	mmGetAccessTokenFromHeader.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAccessTokenFromHeader.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAccessTokenFromHeader
}

// Inspect accepts an inspector function that has same arguments as the IHeaderHelper.GetAccessTokenFromHeader
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) Inspect(f func(ctx echo.Context)) *mIHeaderHelperMockGetAccessTokenFromHeader {
	if mmGetAccessTokenFromHeader.mock.inspectFuncGetAccessTokenFromHeader != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("Inspect function is already set for IHeaderHelperMock.GetAccessTokenFromHeader")
	}

	mmGetAccessTokenFromHeader.mock.inspectFuncGetAccessTokenFromHeader = f

	return mmGetAccessTokenFromHeader
}

// Return sets up results that will be returned by IHeaderHelper.GetAccessTokenFromHeader
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) Return(s1 string, err error) *IHeaderHelperMock {
	if mmGetAccessTokenFromHeader.mock.funcGetAccessTokenFromHeader != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("IHeaderHelperMock.GetAccessTokenFromHeader mock is already set by Set")
	}

	if mmGetAccessTokenFromHeader.defaultExpectation == nil {
		mmGetAccessTokenFromHeader.defaultExpectation = &IHeaderHelperMockGetAccessTokenFromHeaderExpectation{mock: mmGetAccessTokenFromHeader.mock}
	}
	mmGetAccessTokenFromHeader.defaultExpectation.results = &IHeaderHelperMockGetAccessTokenFromHeaderResults{s1, err}
	mmGetAccessTokenFromHeader.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAccessTokenFromHeader.mock
}

// Set uses given function f to mock the IHeaderHelper.GetAccessTokenFromHeader method
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) Set(f func(ctx echo.Context) (s1 string, err error)) *IHeaderHelperMock {
	if mmGetAccessTokenFromHeader.defaultExpectation != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("Default expectation is already set for the IHeaderHelper.GetAccessTokenFromHeader method")
	}

	if len(mmGetAccessTokenFromHeader.expectations) > 0 {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("Some expectations are already set for the IHeaderHelper.GetAccessTokenFromHeader method")
	}

	mmGetAccessTokenFromHeader.mock.funcGetAccessTokenFromHeader = f
	mmGetAccessTokenFromHeader.mock.funcGetAccessTokenFromHeaderOrigin = minimock.CallerInfo(1)
	return mmGetAccessTokenFromHeader.mock
}

// When sets expectation for the IHeaderHelper.GetAccessTokenFromHeader which will trigger the result defined by the following
// Then helper
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) When(ctx echo.Context) *IHeaderHelperMockGetAccessTokenFromHeaderExpectation {
	if mmGetAccessTokenFromHeader.mock.funcGetAccessTokenFromHeader != nil {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("IHeaderHelperMock.GetAccessTokenFromHeader mock is already set by Set")
	}

	expectation := &IHeaderHelperMockGetAccessTokenFromHeaderExpectation{
		mock:               mmGetAccessTokenFromHeader.mock,
		params:             &IHeaderHelperMockGetAccessTokenFromHeaderParams{ctx},
		expectationOrigins: IHeaderHelperMockGetAccessTokenFromHeaderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAccessTokenFromHeader.expectations = append(mmGetAccessTokenFromHeader.expectations, expectation)
	return expectation
}

// Then sets up IHeaderHelper.GetAccessTokenFromHeader return parameters for the expectation previously defined by the When method
func (e *IHeaderHelperMockGetAccessTokenFromHeaderExpectation) Then(s1 string, err error) *IHeaderHelperMock {
	e.results = &IHeaderHelperMockGetAccessTokenFromHeaderResults{s1, err}
	return e.mock
}

// Times sets number of times IHeaderHelper.GetAccessTokenFromHeader should be invoked
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) Times(n uint64) *mIHeaderHelperMockGetAccessTokenFromHeader {
	if n == 0 {
		mmGetAccessTokenFromHeader.mock.t.Fatalf("Times of IHeaderHelperMock.GetAccessTokenFromHeader mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccessTokenFromHeader.expectedInvocations, n)
	mmGetAccessTokenFromHeader.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAccessTokenFromHeader
}

func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) invocationsDone() bool {
	if len(mmGetAccessTokenFromHeader.expectations) == 0 && mmGetAccessTokenFromHeader.defaultExpectation == nil && mmGetAccessTokenFromHeader.mock.funcGetAccessTokenFromHeader == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccessTokenFromHeader.mock.afterGetAccessTokenFromHeaderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccessTokenFromHeader.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccessTokenFromHeader implements mm_header_helper.IHeaderHelper
func (mmGetAccessTokenFromHeader *IHeaderHelperMock) GetAccessTokenFromHeader(ctx echo.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetAccessTokenFromHeader.beforeGetAccessTokenFromHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccessTokenFromHeader.afterGetAccessTokenFromHeaderCounter, 1)

	mmGetAccessTokenFromHeader.t.Helper()

	if mmGetAccessTokenFromHeader.inspectFuncGetAccessTokenFromHeader != nil {
		mmGetAccessTokenFromHeader.inspectFuncGetAccessTokenFromHeader(ctx)
	}

	mm_params := IHeaderHelperMockGetAccessTokenFromHeaderParams{ctx}

	// Record call args
	mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.mutex.Lock()
	mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.callArgs = append(mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.callArgs, &mm_params)
	mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.mutex.Unlock()

	for _, e := range mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.defaultExpectation.paramPtrs

		mm_got := IHeaderHelperMockGetAccessTokenFromHeaderParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccessTokenFromHeader.t.Errorf("IHeaderHelperMock.GetAccessTokenFromHeader got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccessTokenFromHeader.t.Errorf("IHeaderHelperMock.GetAccessTokenFromHeader got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccessTokenFromHeader.GetAccessTokenFromHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccessTokenFromHeader.t.Fatal("No results are set for the IHeaderHelperMock.GetAccessTokenFromHeader")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetAccessTokenFromHeader.funcGetAccessTokenFromHeader != nil {
		return mmGetAccessTokenFromHeader.funcGetAccessTokenFromHeader(ctx)
	}
	mmGetAccessTokenFromHeader.t.Fatalf("Unexpected call to IHeaderHelperMock.GetAccessTokenFromHeader. %v", ctx)
	return
}

// GetAccessTokenFromHeaderAfterCounter returns a count of finished IHeaderHelperMock.GetAccessTokenFromHeader invocations
func (mmGetAccessTokenFromHeader *IHeaderHelperMock) GetAccessTokenFromHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessTokenFromHeader.afterGetAccessTokenFromHeaderCounter)
}

// GetAccessTokenFromHeaderBeforeCounter returns a count of IHeaderHelperMock.GetAccessTokenFromHeader invocations
func (mmGetAccessTokenFromHeader *IHeaderHelperMock) GetAccessTokenFromHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessTokenFromHeader.beforeGetAccessTokenFromHeaderCounter)
}

// Calls returns a list of arguments used in each call to IHeaderHelperMock.GetAccessTokenFromHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccessTokenFromHeader *mIHeaderHelperMockGetAccessTokenFromHeader) Calls() []*IHeaderHelperMockGetAccessTokenFromHeaderParams {
	mmGetAccessTokenFromHeader.mutex.RLock()

	argCopy := make([]*IHeaderHelperMockGetAccessTokenFromHeaderParams, len(mmGetAccessTokenFromHeader.callArgs))
	copy(argCopy, mmGetAccessTokenFromHeader.callArgs)

	mmGetAccessTokenFromHeader.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessTokenFromHeaderDone returns true if the count of the GetAccessTokenFromHeader invocations corresponds
// the number of defined expectations
func (m *IHeaderHelperMock) MinimockGetAccessTokenFromHeaderDone() bool {
	if m.GetAccessTokenFromHeaderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessTokenFromHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessTokenFromHeaderMock.invocationsDone()
}

// MinimockGetAccessTokenFromHeaderInspect logs each unmet expectation
func (m *IHeaderHelperMock) MinimockGetAccessTokenFromHeaderInspect() {
	for _, e := range m.GetAccessTokenFromHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IHeaderHelperMock.GetAccessTokenFromHeader at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAccessTokenFromHeaderCounter := mm_atomic.LoadUint64(&m.afterGetAccessTokenFromHeaderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenFromHeaderMock.defaultExpectation != nil && afterGetAccessTokenFromHeaderCounter < 1 {
		if m.GetAccessTokenFromHeaderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IHeaderHelperMock.GetAccessTokenFromHeader at\n%s", m.GetAccessTokenFromHeaderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IHeaderHelperMock.GetAccessTokenFromHeader at\n%s with params: %#v", m.GetAccessTokenFromHeaderMock.defaultExpectation.expectationOrigins.origin, *m.GetAccessTokenFromHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessTokenFromHeader != nil && afterGetAccessTokenFromHeaderCounter < 1 {
		m.t.Errorf("Expected call to IHeaderHelperMock.GetAccessTokenFromHeader at\n%s", m.funcGetAccessTokenFromHeaderOrigin)
	}

	if !m.GetAccessTokenFromHeaderMock.invocationsDone() && afterGetAccessTokenFromHeaderCounter > 0 {
		m.t.Errorf("Expected %d calls to IHeaderHelperMock.GetAccessTokenFromHeader at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessTokenFromHeaderMock.expectedInvocations), m.GetAccessTokenFromHeaderMock.expectedInvocationsOrigin, afterGetAccessTokenFromHeaderCounter)
	}
}

type mIHeaderHelperMockGetRefreshTokenFromCookie struct {
	optional           bool
	mock               *IHeaderHelperMock
	defaultExpectation *IHeaderHelperMockGetRefreshTokenFromCookieExpectation
	expectations       []*IHeaderHelperMockGetRefreshTokenFromCookieExpectation

	callArgs []*IHeaderHelperMockGetRefreshTokenFromCookieParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IHeaderHelperMockGetRefreshTokenFromCookieExpectation specifies expectation struct of the IHeaderHelper.GetRefreshTokenFromCookie
type IHeaderHelperMockGetRefreshTokenFromCookieExpectation struct {
	mock               *IHeaderHelperMock
	params             *IHeaderHelperMockGetRefreshTokenFromCookieParams
	paramPtrs          *IHeaderHelperMockGetRefreshTokenFromCookieParamPtrs
	expectationOrigins IHeaderHelperMockGetRefreshTokenFromCookieExpectationOrigins
	results            *IHeaderHelperMockGetRefreshTokenFromCookieResults
	returnOrigin       string
	Counter            uint64
}

// IHeaderHelperMockGetRefreshTokenFromCookieParams contains parameters of the IHeaderHelper.GetRefreshTokenFromCookie
type IHeaderHelperMockGetRefreshTokenFromCookieParams struct {
	ctx echo.Context
	key string
}

// IHeaderHelperMockGetRefreshTokenFromCookieParamPtrs contains pointers to parameters of the IHeaderHelper.GetRefreshTokenFromCookie
type IHeaderHelperMockGetRefreshTokenFromCookieParamPtrs struct {
	ctx *echo.Context
	key *string
}

// IHeaderHelperMockGetRefreshTokenFromCookieResults contains results of the IHeaderHelper.GetRefreshTokenFromCookie
type IHeaderHelperMockGetRefreshTokenFromCookieResults struct {
	s1  string
	err error
}

// IHeaderHelperMockGetRefreshTokenFromCookieOrigins contains origins of expectations of the IHeaderHelper.GetRefreshTokenFromCookie
type IHeaderHelperMockGetRefreshTokenFromCookieExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) Optional() *mIHeaderHelperMockGetRefreshTokenFromCookie {
	mmGetRefreshTokenFromCookie.optional = true
	return mmGetRefreshTokenFromCookie
}

// Expect sets up expected params for IHeaderHelper.GetRefreshTokenFromCookie
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) Expect(ctx echo.Context, key string) *mIHeaderHelperMockGetRefreshTokenFromCookie {
	if mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookie != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by Set")
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation == nil {
		mmGetRefreshTokenFromCookie.defaultExpectation = &IHeaderHelperMockGetRefreshTokenFromCookieExpectation{}
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation.paramPtrs != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by ExpectParams functions")
	}

	mmGetRefreshTokenFromCookie.defaultExpectation.params = &IHeaderHelperMockGetRefreshTokenFromCookieParams{ctx, key}
	mmGetRefreshTokenFromCookie.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRefreshTokenFromCookie.expectations {
		if minimock.Equal(e.params, mmGetRefreshTokenFromCookie.defaultExpectation.params) {
			mmGetRefreshTokenFromCookie.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshTokenFromCookie.defaultExpectation.params)
		}
	}

	return mmGetRefreshTokenFromCookie
}

// ExpectCtxParam1 sets up expected param ctx for IHeaderHelper.GetRefreshTokenFromCookie
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) ExpectCtxParam1(ctx echo.Context) *mIHeaderHelperMockGetRefreshTokenFromCookie {
	if mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookie != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by Set")
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation == nil {
		mmGetRefreshTokenFromCookie.defaultExpectation = &IHeaderHelperMockGetRefreshTokenFromCookieExpectation{}
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation.params != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by Expect")
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation.paramPtrs == nil {
		mmGetRefreshTokenFromCookie.defaultExpectation.paramPtrs = &IHeaderHelperMockGetRefreshTokenFromCookieParamPtrs{}
	}
	mmGetRefreshTokenFromCookie.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRefreshTokenFromCookie.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRefreshTokenFromCookie
}

// ExpectKeyParam2 sets up expected param key for IHeaderHelper.GetRefreshTokenFromCookie
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) ExpectKeyParam2(key string) *mIHeaderHelperMockGetRefreshTokenFromCookie {
	if mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookie != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by Set")
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation == nil {
		mmGetRefreshTokenFromCookie.defaultExpectation = &IHeaderHelperMockGetRefreshTokenFromCookieExpectation{}
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation.params != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by Expect")
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation.paramPtrs == nil {
		mmGetRefreshTokenFromCookie.defaultExpectation.paramPtrs = &IHeaderHelperMockGetRefreshTokenFromCookieParamPtrs{}
	}
	mmGetRefreshTokenFromCookie.defaultExpectation.paramPtrs.key = &key
	mmGetRefreshTokenFromCookie.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGetRefreshTokenFromCookie
}

// Inspect accepts an inspector function that has same arguments as the IHeaderHelper.GetRefreshTokenFromCookie
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) Inspect(f func(ctx echo.Context, key string)) *mIHeaderHelperMockGetRefreshTokenFromCookie {
	if mmGetRefreshTokenFromCookie.mock.inspectFuncGetRefreshTokenFromCookie != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("Inspect function is already set for IHeaderHelperMock.GetRefreshTokenFromCookie")
	}

	mmGetRefreshTokenFromCookie.mock.inspectFuncGetRefreshTokenFromCookie = f

	return mmGetRefreshTokenFromCookie
}

// Return sets up results that will be returned by IHeaderHelper.GetRefreshTokenFromCookie
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) Return(s1 string, err error) *IHeaderHelperMock {
	if mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookie != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by Set")
	}

	if mmGetRefreshTokenFromCookie.defaultExpectation == nil {
		mmGetRefreshTokenFromCookie.defaultExpectation = &IHeaderHelperMockGetRefreshTokenFromCookieExpectation{mock: mmGetRefreshTokenFromCookie.mock}
	}
	mmGetRefreshTokenFromCookie.defaultExpectation.results = &IHeaderHelperMockGetRefreshTokenFromCookieResults{s1, err}
	mmGetRefreshTokenFromCookie.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRefreshTokenFromCookie.mock
}

// Set uses given function f to mock the IHeaderHelper.GetRefreshTokenFromCookie method
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) Set(f func(ctx echo.Context, key string) (s1 string, err error)) *IHeaderHelperMock {
	if mmGetRefreshTokenFromCookie.defaultExpectation != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("Default expectation is already set for the IHeaderHelper.GetRefreshTokenFromCookie method")
	}

	if len(mmGetRefreshTokenFromCookie.expectations) > 0 {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("Some expectations are already set for the IHeaderHelper.GetRefreshTokenFromCookie method")
	}

	mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookie = f
	mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookieOrigin = minimock.CallerInfo(1)
	return mmGetRefreshTokenFromCookie.mock
}

// When sets expectation for the IHeaderHelper.GetRefreshTokenFromCookie which will trigger the result defined by the following
// Then helper
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) When(ctx echo.Context, key string) *IHeaderHelperMockGetRefreshTokenFromCookieExpectation {
	if mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookie != nil {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("IHeaderHelperMock.GetRefreshTokenFromCookie mock is already set by Set")
	}

	expectation := &IHeaderHelperMockGetRefreshTokenFromCookieExpectation{
		mock:               mmGetRefreshTokenFromCookie.mock,
		params:             &IHeaderHelperMockGetRefreshTokenFromCookieParams{ctx, key},
		expectationOrigins: IHeaderHelperMockGetRefreshTokenFromCookieExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRefreshTokenFromCookie.expectations = append(mmGetRefreshTokenFromCookie.expectations, expectation)
	return expectation
}

// Then sets up IHeaderHelper.GetRefreshTokenFromCookie return parameters for the expectation previously defined by the When method
func (e *IHeaderHelperMockGetRefreshTokenFromCookieExpectation) Then(s1 string, err error) *IHeaderHelperMock {
	e.results = &IHeaderHelperMockGetRefreshTokenFromCookieResults{s1, err}
	return e.mock
}

// Times sets number of times IHeaderHelper.GetRefreshTokenFromCookie should be invoked
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) Times(n uint64) *mIHeaderHelperMockGetRefreshTokenFromCookie {
	if n == 0 {
		mmGetRefreshTokenFromCookie.mock.t.Fatalf("Times of IHeaderHelperMock.GetRefreshTokenFromCookie mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefreshTokenFromCookie.expectedInvocations, n)
	mmGetRefreshTokenFromCookie.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRefreshTokenFromCookie
}

func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) invocationsDone() bool {
	if len(mmGetRefreshTokenFromCookie.expectations) == 0 && mmGetRefreshTokenFromCookie.defaultExpectation == nil && mmGetRefreshTokenFromCookie.mock.funcGetRefreshTokenFromCookie == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefreshTokenFromCookie.mock.afterGetRefreshTokenFromCookieCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefreshTokenFromCookie.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefreshTokenFromCookie implements mm_header_helper.IHeaderHelper
func (mmGetRefreshTokenFromCookie *IHeaderHelperMock) GetRefreshTokenFromCookie(ctx echo.Context, key string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetRefreshTokenFromCookie.beforeGetRefreshTokenFromCookieCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshTokenFromCookie.afterGetRefreshTokenFromCookieCounter, 1)

	mmGetRefreshTokenFromCookie.t.Helper()

	if mmGetRefreshTokenFromCookie.inspectFuncGetRefreshTokenFromCookie != nil {
		mmGetRefreshTokenFromCookie.inspectFuncGetRefreshTokenFromCookie(ctx, key)
	}

	mm_params := IHeaderHelperMockGetRefreshTokenFromCookieParams{ctx, key}

	// Record call args
	mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.mutex.Lock()
	mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.callArgs = append(mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.callArgs, &mm_params)
	mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.mutex.Unlock()

	for _, e := range mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation.paramPtrs

		mm_got := IHeaderHelperMockGetRefreshTokenFromCookieParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefreshTokenFromCookie.t.Errorf("IHeaderHelperMock.GetRefreshTokenFromCookie got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGetRefreshTokenFromCookie.t.Errorf("IHeaderHelperMock.GetRefreshTokenFromCookie got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshTokenFromCookie.t.Errorf("IHeaderHelperMock.GetRefreshTokenFromCookie got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshTokenFromCookie.GetRefreshTokenFromCookieMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshTokenFromCookie.t.Fatal("No results are set for the IHeaderHelperMock.GetRefreshTokenFromCookie")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetRefreshTokenFromCookie.funcGetRefreshTokenFromCookie != nil {
		return mmGetRefreshTokenFromCookie.funcGetRefreshTokenFromCookie(ctx, key)
	}
	mmGetRefreshTokenFromCookie.t.Fatalf("Unexpected call to IHeaderHelperMock.GetRefreshTokenFromCookie. %v %v", ctx, key)
	return
}

// GetRefreshTokenFromCookieAfterCounter returns a count of finished IHeaderHelperMock.GetRefreshTokenFromCookie invocations
func (mmGetRefreshTokenFromCookie *IHeaderHelperMock) GetRefreshTokenFromCookieAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshTokenFromCookie.afterGetRefreshTokenFromCookieCounter)
}

// GetRefreshTokenFromCookieBeforeCounter returns a count of IHeaderHelperMock.GetRefreshTokenFromCookie invocations
func (mmGetRefreshTokenFromCookie *IHeaderHelperMock) GetRefreshTokenFromCookieBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshTokenFromCookie.beforeGetRefreshTokenFromCookieCounter)
}

// Calls returns a list of arguments used in each call to IHeaderHelperMock.GetRefreshTokenFromCookie.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshTokenFromCookie *mIHeaderHelperMockGetRefreshTokenFromCookie) Calls() []*IHeaderHelperMockGetRefreshTokenFromCookieParams {
	mmGetRefreshTokenFromCookie.mutex.RLock()

	argCopy := make([]*IHeaderHelperMockGetRefreshTokenFromCookieParams, len(mmGetRefreshTokenFromCookie.callArgs))
	copy(argCopy, mmGetRefreshTokenFromCookie.callArgs)

	mmGetRefreshTokenFromCookie.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenFromCookieDone returns true if the count of the GetRefreshTokenFromCookie invocations corresponds
// the number of defined expectations
func (m *IHeaderHelperMock) MinimockGetRefreshTokenFromCookieDone() bool {
	if m.GetRefreshTokenFromCookieMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefreshTokenFromCookieMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefreshTokenFromCookieMock.invocationsDone()
}

// MinimockGetRefreshTokenFromCookieInspect logs each unmet expectation
func (m *IHeaderHelperMock) MinimockGetRefreshTokenFromCookieInspect() {
	for _, e := range m.GetRefreshTokenFromCookieMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IHeaderHelperMock.GetRefreshTokenFromCookie at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRefreshTokenFromCookieCounter := mm_atomic.LoadUint64(&m.afterGetRefreshTokenFromCookieCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenFromCookieMock.defaultExpectation != nil && afterGetRefreshTokenFromCookieCounter < 1 {
		if m.GetRefreshTokenFromCookieMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IHeaderHelperMock.GetRefreshTokenFromCookie at\n%s", m.GetRefreshTokenFromCookieMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IHeaderHelperMock.GetRefreshTokenFromCookie at\n%s with params: %#v", m.GetRefreshTokenFromCookieMock.defaultExpectation.expectationOrigins.origin, *m.GetRefreshTokenFromCookieMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshTokenFromCookie != nil && afterGetRefreshTokenFromCookieCounter < 1 {
		m.t.Errorf("Expected call to IHeaderHelperMock.GetRefreshTokenFromCookie at\n%s", m.funcGetRefreshTokenFromCookieOrigin)
	}

	if !m.GetRefreshTokenFromCookieMock.invocationsDone() && afterGetRefreshTokenFromCookieCounter > 0 {
		m.t.Errorf("Expected %d calls to IHeaderHelperMock.GetRefreshTokenFromCookie at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefreshTokenFromCookieMock.expectedInvocations), m.GetRefreshTokenFromCookieMock.expectedInvocationsOrigin, afterGetRefreshTokenFromCookieCounter)
	}
}

type mIHeaderHelperMockSetRefreshTokenInCookie struct {
	optional           bool
	mock               *IHeaderHelperMock
	defaultExpectation *IHeaderHelperMockSetRefreshTokenInCookieExpectation
	expectations       []*IHeaderHelperMockSetRefreshTokenInCookieExpectation

	callArgs []*IHeaderHelperMockSetRefreshTokenInCookieParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IHeaderHelperMockSetRefreshTokenInCookieExpectation specifies expectation struct of the IHeaderHelper.SetRefreshTokenInCookie
type IHeaderHelperMockSetRefreshTokenInCookieExpectation struct {
	mock               *IHeaderHelperMock
	params             *IHeaderHelperMockSetRefreshTokenInCookieParams
	paramPtrs          *IHeaderHelperMockSetRefreshTokenInCookieParamPtrs
	expectationOrigins IHeaderHelperMockSetRefreshTokenInCookieExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// IHeaderHelperMockSetRefreshTokenInCookieParams contains parameters of the IHeaderHelper.SetRefreshTokenInCookie
type IHeaderHelperMockSetRefreshTokenInCookieParams struct {
	ctx   echo.Context
	key   string
	value string
}

// IHeaderHelperMockSetRefreshTokenInCookieParamPtrs contains pointers to parameters of the IHeaderHelper.SetRefreshTokenInCookie
type IHeaderHelperMockSetRefreshTokenInCookieParamPtrs struct {
	ctx   *echo.Context
	key   *string
	value *string
}

// IHeaderHelperMockSetRefreshTokenInCookieOrigins contains origins of expectations of the IHeaderHelper.SetRefreshTokenInCookie
type IHeaderHelperMockSetRefreshTokenInCookieExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) Optional() *mIHeaderHelperMockSetRefreshTokenInCookie {
	mmSetRefreshTokenInCookie.optional = true
	return mmSetRefreshTokenInCookie
}

// Expect sets up expected params for IHeaderHelper.SetRefreshTokenInCookie
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) Expect(ctx echo.Context, key string, value string) *mIHeaderHelperMockSetRefreshTokenInCookie {
	if mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Set")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation == nil {
		mmSetRefreshTokenInCookie.defaultExpectation = &IHeaderHelperMockSetRefreshTokenInCookieExpectation{}
	}

	if mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by ExpectParams functions")
	}

	mmSetRefreshTokenInCookie.defaultExpectation.params = &IHeaderHelperMockSetRefreshTokenInCookieParams{ctx, key, value}
	mmSetRefreshTokenInCookie.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetRefreshTokenInCookie.expectations {
		if minimock.Equal(e.params, mmSetRefreshTokenInCookie.defaultExpectation.params) {
			mmSetRefreshTokenInCookie.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetRefreshTokenInCookie.defaultExpectation.params)
		}
	}

	return mmSetRefreshTokenInCookie
}

// ExpectCtxParam1 sets up expected param ctx for IHeaderHelper.SetRefreshTokenInCookie
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) ExpectCtxParam1(ctx echo.Context) *mIHeaderHelperMockSetRefreshTokenInCookie {
	if mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Set")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation == nil {
		mmSetRefreshTokenInCookie.defaultExpectation = &IHeaderHelperMockSetRefreshTokenInCookieExpectation{}
	}

	if mmSetRefreshTokenInCookie.defaultExpectation.params != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Expect")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs == nil {
		mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs = &IHeaderHelperMockSetRefreshTokenInCookieParamPtrs{}
	}
	mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetRefreshTokenInCookie.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetRefreshTokenInCookie
}

// ExpectKeyParam2 sets up expected param key for IHeaderHelper.SetRefreshTokenInCookie
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) ExpectKeyParam2(key string) *mIHeaderHelperMockSetRefreshTokenInCookie {
	if mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Set")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation == nil {
		mmSetRefreshTokenInCookie.defaultExpectation = &IHeaderHelperMockSetRefreshTokenInCookieExpectation{}
	}

	if mmSetRefreshTokenInCookie.defaultExpectation.params != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Expect")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs == nil {
		mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs = &IHeaderHelperMockSetRefreshTokenInCookieParamPtrs{}
	}
	mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs.key = &key
	mmSetRefreshTokenInCookie.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSetRefreshTokenInCookie
}

// ExpectValueParam3 sets up expected param value for IHeaderHelper.SetRefreshTokenInCookie
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) ExpectValueParam3(value string) *mIHeaderHelperMockSetRefreshTokenInCookie {
	if mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Set")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation == nil {
		mmSetRefreshTokenInCookie.defaultExpectation = &IHeaderHelperMockSetRefreshTokenInCookieExpectation{}
	}

	if mmSetRefreshTokenInCookie.defaultExpectation.params != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Expect")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs == nil {
		mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs = &IHeaderHelperMockSetRefreshTokenInCookieParamPtrs{}
	}
	mmSetRefreshTokenInCookie.defaultExpectation.paramPtrs.value = &value
	mmSetRefreshTokenInCookie.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetRefreshTokenInCookie
}

// Inspect accepts an inspector function that has same arguments as the IHeaderHelper.SetRefreshTokenInCookie
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) Inspect(f func(ctx echo.Context, key string, value string)) *mIHeaderHelperMockSetRefreshTokenInCookie {
	if mmSetRefreshTokenInCookie.mock.inspectFuncSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("Inspect function is already set for IHeaderHelperMock.SetRefreshTokenInCookie")
	}

	mmSetRefreshTokenInCookie.mock.inspectFuncSetRefreshTokenInCookie = f

	return mmSetRefreshTokenInCookie
}

// Return sets up results that will be returned by IHeaderHelper.SetRefreshTokenInCookie
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) Return() *IHeaderHelperMock {
	if mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("IHeaderHelperMock.SetRefreshTokenInCookie mock is already set by Set")
	}

	if mmSetRefreshTokenInCookie.defaultExpectation == nil {
		mmSetRefreshTokenInCookie.defaultExpectation = &IHeaderHelperMockSetRefreshTokenInCookieExpectation{mock: mmSetRefreshTokenInCookie.mock}
	}

	mmSetRefreshTokenInCookie.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetRefreshTokenInCookie.mock
}

// Set uses given function f to mock the IHeaderHelper.SetRefreshTokenInCookie method
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) Set(f func(ctx echo.Context, key string, value string)) *IHeaderHelperMock {
	if mmSetRefreshTokenInCookie.defaultExpectation != nil {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("Default expectation is already set for the IHeaderHelper.SetRefreshTokenInCookie method")
	}

	if len(mmSetRefreshTokenInCookie.expectations) > 0 {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("Some expectations are already set for the IHeaderHelper.SetRefreshTokenInCookie method")
	}

	mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookie = f
	mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookieOrigin = minimock.CallerInfo(1)
	return mmSetRefreshTokenInCookie.mock
}

// Times sets number of times IHeaderHelper.SetRefreshTokenInCookie should be invoked
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) Times(n uint64) *mIHeaderHelperMockSetRefreshTokenInCookie {
	if n == 0 {
		mmSetRefreshTokenInCookie.mock.t.Fatalf("Times of IHeaderHelperMock.SetRefreshTokenInCookie mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetRefreshTokenInCookie.expectedInvocations, n)
	mmSetRefreshTokenInCookie.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetRefreshTokenInCookie
}

func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) invocationsDone() bool {
	if len(mmSetRefreshTokenInCookie.expectations) == 0 && mmSetRefreshTokenInCookie.defaultExpectation == nil && mmSetRefreshTokenInCookie.mock.funcSetRefreshTokenInCookie == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetRefreshTokenInCookie.mock.afterSetRefreshTokenInCookieCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetRefreshTokenInCookie.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetRefreshTokenInCookie implements mm_header_helper.IHeaderHelper
func (mmSetRefreshTokenInCookie *IHeaderHelperMock) SetRefreshTokenInCookie(ctx echo.Context, key string, value string) {
	mm_atomic.AddUint64(&mmSetRefreshTokenInCookie.beforeSetRefreshTokenInCookieCounter, 1)
	defer mm_atomic.AddUint64(&mmSetRefreshTokenInCookie.afterSetRefreshTokenInCookieCounter, 1)

	mmSetRefreshTokenInCookie.t.Helper()

	if mmSetRefreshTokenInCookie.inspectFuncSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.inspectFuncSetRefreshTokenInCookie(ctx, key, value)
	}

	mm_params := IHeaderHelperMockSetRefreshTokenInCookieParams{ctx, key, value}

	// Record call args
	mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.mutex.Lock()
	mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.callArgs = append(mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.callArgs, &mm_params)
	mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.mutex.Unlock()

	for _, e := range mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation.Counter, 1)
		mm_want := mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation.params
		mm_want_ptrs := mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation.paramPtrs

		mm_got := IHeaderHelperMockSetRefreshTokenInCookieParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetRefreshTokenInCookie.t.Errorf("IHeaderHelperMock.SetRefreshTokenInCookie got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSetRefreshTokenInCookie.t.Errorf("IHeaderHelperMock.SetRefreshTokenInCookie got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetRefreshTokenInCookie.t.Errorf("IHeaderHelperMock.SetRefreshTokenInCookie got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetRefreshTokenInCookie.t.Errorf("IHeaderHelperMock.SetRefreshTokenInCookie got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetRefreshTokenInCookie.SetRefreshTokenInCookieMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetRefreshTokenInCookie.funcSetRefreshTokenInCookie != nil {
		mmSetRefreshTokenInCookie.funcSetRefreshTokenInCookie(ctx, key, value)
		return
	}
	mmSetRefreshTokenInCookie.t.Fatalf("Unexpected call to IHeaderHelperMock.SetRefreshTokenInCookie. %v %v %v", ctx, key, value)

}

// SetRefreshTokenInCookieAfterCounter returns a count of finished IHeaderHelperMock.SetRefreshTokenInCookie invocations
func (mmSetRefreshTokenInCookie *IHeaderHelperMock) SetRefreshTokenInCookieAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRefreshTokenInCookie.afterSetRefreshTokenInCookieCounter)
}

// SetRefreshTokenInCookieBeforeCounter returns a count of IHeaderHelperMock.SetRefreshTokenInCookie invocations
func (mmSetRefreshTokenInCookie *IHeaderHelperMock) SetRefreshTokenInCookieBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRefreshTokenInCookie.beforeSetRefreshTokenInCookieCounter)
}

// Calls returns a list of arguments used in each call to IHeaderHelperMock.SetRefreshTokenInCookie.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetRefreshTokenInCookie *mIHeaderHelperMockSetRefreshTokenInCookie) Calls() []*IHeaderHelperMockSetRefreshTokenInCookieParams {
	mmSetRefreshTokenInCookie.mutex.RLock()

	argCopy := make([]*IHeaderHelperMockSetRefreshTokenInCookieParams, len(mmSetRefreshTokenInCookie.callArgs))
	copy(argCopy, mmSetRefreshTokenInCookie.callArgs)

	mmSetRefreshTokenInCookie.mutex.RUnlock()

	return argCopy
}

// MinimockSetRefreshTokenInCookieDone returns true if the count of the SetRefreshTokenInCookie invocations corresponds
// the number of defined expectations
func (m *IHeaderHelperMock) MinimockSetRefreshTokenInCookieDone() bool {
	if m.SetRefreshTokenInCookieMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetRefreshTokenInCookieMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetRefreshTokenInCookieMock.invocationsDone()
}

// MinimockSetRefreshTokenInCookieInspect logs each unmet expectation
func (m *IHeaderHelperMock) MinimockSetRefreshTokenInCookieInspect() {
	for _, e := range m.SetRefreshTokenInCookieMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IHeaderHelperMock.SetRefreshTokenInCookie at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetRefreshTokenInCookieCounter := mm_atomic.LoadUint64(&m.afterSetRefreshTokenInCookieCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetRefreshTokenInCookieMock.defaultExpectation != nil && afterSetRefreshTokenInCookieCounter < 1 {
		if m.SetRefreshTokenInCookieMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IHeaderHelperMock.SetRefreshTokenInCookie at\n%s", m.SetRefreshTokenInCookieMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IHeaderHelperMock.SetRefreshTokenInCookie at\n%s with params: %#v", m.SetRefreshTokenInCookieMock.defaultExpectation.expectationOrigins.origin, *m.SetRefreshTokenInCookieMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRefreshTokenInCookie != nil && afterSetRefreshTokenInCookieCounter < 1 {
		m.t.Errorf("Expected call to IHeaderHelperMock.SetRefreshTokenInCookie at\n%s", m.funcSetRefreshTokenInCookieOrigin)
	}

	if !m.SetRefreshTokenInCookieMock.invocationsDone() && afterSetRefreshTokenInCookieCounter > 0 {
		m.t.Errorf("Expected %d calls to IHeaderHelperMock.SetRefreshTokenInCookie at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetRefreshTokenInCookieMock.expectedInvocations), m.SetRefreshTokenInCookieMock.expectedInvocationsOrigin, afterSetRefreshTokenInCookieCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IHeaderHelperMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAccessTokenFromHeaderInspect()

			m.MinimockGetRefreshTokenFromCookieInspect()

			m.MinimockSetRefreshTokenInCookieInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IHeaderHelperMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IHeaderHelperMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAccessTokenFromHeaderDone() &&
		m.MinimockGetRefreshTokenFromCookieDone() &&
		m.MinimockSetRefreshTokenInCookieDone()
}
